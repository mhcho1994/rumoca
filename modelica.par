%start stored_definition
%title "Modelica grammar"
%comment "Modelica grammar 3.7-dev for `parol`"
%line_comment "//"
%t_type crate::modelica_grammar::OwnedToken
%nt_type stored_definition = crate::modelica_grammar::StoredDefinition
%nt_type class_definition = crate::modelica_grammar::ClassDefinition
%nt_type class_prefixes = crate::modelica_grammar::ClassPrefixes
%nt_type class_specifier = crate::modelica_grammar::ClassSpecifier
%nt_type long_class_specifier = crate::modelica_grammar::ClassSpecifier
%nt_type composition = crate::modelica_grammar::Composition
%nt_type element_list = crate::modelica_grammar::ElementList
%nt_type element = crate::modelica_grammar::Element
%nt_type component_clause = crate::modelica_grammar::ComponentClause
%nt_type component_list = crate::modelica_grammar::ComponentList
%nt_type component_declaration = crate::modelica_grammar::ComponentDeclaration
%nt_type declaration = crate::modelica_grammar::Declaration
%nt_type type_prefix = crate::modelica_grammar::TypePrefix
%nt_type type_specifier = crate::modelica_grammar::TypeSpecifier
%nt_type equation_section = crate::modelica_grammar::EquationSection
%nt_type ident = crate::modelica_grammar::Ident
%nt_type some_equation = crate::modelica_grammar::Equation
%nt_type simple_expression = crate::modelica_grammar::SimpleExpression
%nt_type logical_expression = crate::modelica_grammar::LogicalExpression
%nt_type logical_term = crate::modelica_grammar::LogicalTerm
%nt_type logical_factor = crate::modelica_grammar::LogicalFactor
%nt_type relation = crate::modelica_grammar::Relation
%nt_type relational_operator = crate::modelica_grammar::RelationalOperator
%nt_type arithmetic_expression = crate::modelica_grammar::ArithmeticExpression
%nt_type add_operator = crate::modelica_grammar::AddOperator
%nt_type term = crate::modelica_grammar::Term
%nt_type mul_operator = crate::modelica_grammar::MulOperator
%nt_type factor = crate::modelica_grammar::Factor
%nt_type primary = crate::modelica_grammar::Primary
%nt_type component_reference = crate::modelica_grammar::ComponentReference
%nt_type unsigned_integer = crate::modelica_grammar::UnsignedInteger
%nt_type name = crate::modelica_grammar::Name

%%
//=============================================================================
// 2.3.3 Modelica Keywords

// algorithm: 'algorithm';
and: 'and';
// annotation: 'annotation';
block: 'block';
// break: 'break';
class: 'class';
// connect: 'connect';
connector: 'connector';
constant: 'constant';
// constrainedby: 'constrainedby';
// der: 'der';
discrete: 'discrete';
// each: 'each';
// else: 'else';
// elseif: 'elseif';
// elsewhen: 'elsewhen';
encapsulated: 'encapsulated';
end: 'end';
// enumeration: 'enumeration';
equation: 'equation';
expandable: 'expandable';
// extends: 'extends';
// external: 'external';
// false: 'false';
final: 'final';
flow: 'flow';
// for: 'for';
function: 'function';
// if: 'if';
// import: 'import';
impure: 'impure';
// in: 'in';
initial: 'initial';
// inner: 'inner';
input: 'input';
// loop: 'loop';
model: 'model';
not: 'not';
operator: 'operator';
or: 'or';
// outer: 'outer';
output: 'output';
package: 'package';
parameter: 'parameter';
// partial: 'partial';
// protected: 'protected';
// public: 'public';
pure: 'pure';
record: 'record';
// redeclare: 'redeclare';
// replaceable: 'replaceable';
// return: 'return';
stream: 'stream';
// then: 'then';
// true: 'true';
type: 'type';
// when: 'when';
// while: 'while';
within: 'within';

//=============================================================================
// A.1 Lexical conventions
// IDENT = NON-DIGIT { DIGIT | NON-DIGIT } | Q-IDENT
ident
    : /[_a-zA-Z][_a-zA-Z0-9]*/
    ;

// Q-IDENT = "'" { Q-CHAR | S-ESCAPE } "'"

// NON-DIGIT = "_" | letters "a"..."z" | letters "A"..."Z"

// DIGIT = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

// Q-CHAR = NON-DIGIT | DIGIT | "!" | "#" | "$" | "%" | "&" | "(" | ")"
//    | "*" | "+" | "," | "-" | "." | "/" | ":" | ";" | "<" | ">" | "="
//    | "?" | "@" | "[" | "]" | "^" | "{" | "}" | "|" | "~" | " " | """

// S-ESCAPE = "\'" | "\"" | "\?" | "\\"
//    | "\a" | "\b" | "\f" | "\n" | "\r" | "\t" | "\v"

// STRING = """ { S-CHAR | S-ESCAPE } """

// S-CHAR is any member of the Unicode character set
// (https://unicode.org; see section 13.4 for storing as UTF-8 on files)
// except double-quote â€˜â€â€™, and backslash â€˜\â€™.


// UNSIGNED-INTEGER = DIGIT { DIGIT }
unsigned_integer
    : /[0-9]+/
    ;
// UNSIGNED-REAL =
//    UNSIGNED-INTEGER  "." [ UNSIGNED-INTEGER ]
//    | UNSIGNED_INTEGER [ "." [ UNSIGNED_INTEGER ] ]
//      ( "e" | "E" ) [ "+" | "-" ] UNSIGNED-INTEGER
//    | "."  UNSIGNED-INTEGER [ ( "e" | "E" ) [ "+" | "-" ] UNSIGNED-INTEGER ]


//=============================================================================
// A.2.1 Stored Definition â€“ Within
// âœ…: Implemented,  ğŸŸ¥: Not-Implemented, ğŸŸ¨: Partial

//âœ… stored-definition :
//âœ…    [ within [ name ] ";" ]
//âœ…    { [ final ] class-definition ";" }
stored_definition :
    [ within [ name ] ';' ]
    { [ final ] class_definition ';' }
    ;

//=============================================================================
// A.2.2 Class Definition
// âœ…: Implemented,  ğŸŸ¥: Not-Implemented, ğŸŸ¨: Partial

//âœ… class-definition :
//âœ…    [ encapsulated ] class-prefixes class-specifier
class_definition :
    [ encapsulated ] class_prefixes class_specifier
    ;

//âœ… class-prefixes :
//âœ…    [ partial ]
//âœ…    ( class
//âœ…      | model
//âœ…      | [ operator ] record
//âœ…      | block
//âœ…      | [ expandable ] connector
//âœ…      | type
//âœ…      | package
//âœ…      | [ pure | impure ] [ operator ] function
//âœ…      | operator
//âœ…    )
class_prefixes :
    [ 'partial' ]
    ( class
        | model
        | [ operator ] record
        | block
        | [ expandable ] connector
        | type
        | package
        | [ pure | impure ] [ operator ] function
        | operator
    )
    ;

//ğŸŸ¨ class-specifier :
//ğŸŸ¨    long-class-specifier
//ğŸŸ¥    | short-class-specifier
//ğŸŸ¥    | der-class-specifier
class_specifier :
    long_class_specifier
    ;

//ğŸŸ¨ long-class-specifier :
//ğŸŸ¨    IDENT description-string composition end IDENT
//ğŸŸ¥    | extends IDENT [ class-modification ] description-string composition end IDENT
long_class_specifier :
    ident@name composition end^ ident
    ;

//ğŸŸ¥ short-class-specifier :
//ğŸŸ¥    IDENT "=" base-prefix type-specifier [ array-subscripts ]
//ğŸŸ¥    [ class-modification ] description
//ğŸŸ¥    | IDENT "=" enumeration "(" ( [ enum-list ] | ":" ) ")" description

//ğŸŸ¥ der-class-specifier :
//ğŸŸ¥    IDENT "=" der "(" type-specifier "," IDENT { "," IDENT } ")" description

//ğŸŸ¥ base-prefix :
//ğŸŸ¥    [ input | output ]

//ğŸŸ¥ enum-list :
//ğŸŸ¥    enumeration-literal { "," enumeration-literal }

//ğŸŸ¥ enumeration-literal :
//ğŸŸ¥    IDENT description

//ğŸŸ¥ composition :
//ğŸŸ¥    element-list
//ğŸŸ¥    { public element-list
//ğŸŸ¥      | protected element-list
//ğŸŸ¥      | equation-section
//ğŸŸ¥      | algorithm-section
//ğŸŸ¥    }
//ğŸŸ¥    [ external [ language-specification ]
//ğŸŸ¥      [ external-function-call ] [ annotation-clause ] ";"
//ğŸŸ¥    ]
//ğŸŸ¥    [ annotation-clause ";" ]
composition :
    element_list { equation_section }
    ;

//ğŸŸ¥ language-specification :
//ğŸŸ¥    STRING

//ğŸŸ¥ external-function-call :
//ğŸŸ¥    [ component-reference "=" ]
//ğŸŸ¥    IDENT "(" [ expression-list ] ")"

element_list :
    { element ';'^ }
    ;

//ğŸŸ¥ element :
//ğŸŸ¥    import-clause
//ğŸŸ¥    | extends-clause
//ğŸŸ¥    | [ redeclare ]
//ğŸŸ¥      [ final ]
//ğŸŸ¥      [ inner ] [ outer ]
//ğŸŸ¥      ( class-definition
//ğŸŸ¥        | component-clause
//ğŸŸ¥        | replaceable ( class-definition | component-clause )
//ğŸŸ¥          [ constraining-clause description ]
//ğŸŸ¥      )
element :
    component_clause
    ;

//ğŸŸ¥ import-clause :
//ğŸŸ¥    import
//ğŸŸ¥    ( IDENT "=" name
//ğŸŸ¥      | name [ ".*" | "." ( "*" | "{" import-list "}" ) ]
//ğŸŸ¥    )
//ğŸŸ¥    description

//ğŸŸ¥ import-list :
//ğŸŸ¥    IDENT { "," IDENT }

//=============================================================================
// A.2.3 Extends
// âœ…: Implemented,  ğŸŸ¥: Not-Implemented, ğŸŸ¨: Partial

//ğŸŸ¥ extends-clause :
//ğŸŸ¥    extends type-specifier [ class-or-inheritance-modification ] [ annotation-clause ]

//ğŸŸ¥ constraining-clause :
//ğŸŸ¥    constrainedby type-specifier [ class-modification ]

//ğŸŸ¥ class-or-inheritance-modification :
//ğŸŸ¥    "(" [ argument-or-inheritance-modification-list ] ")"

//ğŸŸ¥ argument-or-inheritance-modification-list :
//ğŸŸ¥     ( argument | inheritance-modification ) { "," ( argument | inheritance-modification ) }

//ğŸŸ¥ inheritance-modification :
//ğŸŸ¥     break ( connect-equation | IDENT )

//-----------------------------------------------------------------------------
// A.2.4 Component Clause
// âœ…: Implemented,  ğŸŸ¥: Not-Implemented, ğŸŸ¨: Partial

//ğŸŸ¨ component-clause :
//ğŸŸ¨    type-prefix type-specifier [ array-subscripts ] component-list
component_clause :
    type_prefix type_specifier component_list
    ;

//âœ… type-prefix :
//âœ…    [ flow | stream ]
//âœ…    [ discrete | parameter | constant ]
//âœ…    [ input | output ]
type_prefix:
    [ flow | stream ]
    [ discrete | parameter | constant ]
    [ input | output ]
    ;

//âœ… component-list :
//âœ…    component-declaration { "," component-declaration }
component_list :
    component_declaration { ','^ component_declaration }
    ;

//ğŸŸ¨ component-declaration :
//ğŸŸ¨    declaration [ condition-attribute ] description
component_declaration :
    declaration
    ;

//ğŸŸ¥ condition-attribute :
//ğŸŸ¥    if expression

//ğŸŸ¨ declaration :
//ğŸŸ¨    IDENT [ array-subscripts ] [ modification ]
declaration :
    ident
    ;

//=============================================================================
// A.2.5 Modification
// âœ…: Implemented,  ğŸŸ¥: Not-Implemented, ğŸŸ¨: Partial

//ğŸŸ¥ modification :
//ğŸŸ¥    class-modification [ "=" modification-expression ]
//ğŸŸ¥    | "=" modification-expression

//ğŸŸ¥ modification-expression :
//ğŸŸ¥    expression
//ğŸŸ¥    | break

//ğŸŸ¥ class-modification :
//ğŸŸ¥    "(" [ argument-list ] ")"

//ğŸŸ¥ argument-list :
//ğŸŸ¥    argument { "," argument }

//ğŸŸ¥ argument :
//ğŸŸ¥    element-modification-or-replaceable
//ğŸŸ¥    | element-redeclaration

//ğŸŸ¥ element-modification-or-replaceable :
//ğŸŸ¥    [ each ] [ final ] ( element-modification | element-replaceable )

//ğŸŸ¥ element-modification :
//ğŸŸ¥    name [ modification ] description-string

//ğŸŸ¥ element-redeclaration :
//ğŸŸ¥    redeclare [ each ] [ final ]
//ğŸŸ¥    ( short-class-definition | component-clause1 | element-replaceable )

//ğŸŸ¥ element-replaceable :
//ğŸŸ¥    replaceable ( short-class-definition | component-clause1 )
//ğŸŸ¥    [ constraining-clause ]

//ğŸŸ¥ component-clause1 :
//ğŸŸ¥    type-prefix type-specifier component-declaration1

//ğŸŸ¥ component-declaration1 :
//ğŸŸ¥    declaration description

//ğŸŸ¥ short-class-definition :
//ğŸŸ¥    class-prefixes short-class-specifier

//=============================================================================
// A.2.6 Equations
// âœ…: Implemented,  ğŸŸ¥: Not-Implemented, ğŸŸ¨: Partial

//âœ… equation-section :
//âœ…    [ initial ] equation { some-equation ";" }
equation_section :
    [ initial ] equation^ { some_equation ';'^ }
    ;

//ğŸŸ¥ algorithm-section :
//ğŸŸ¥    [ initial ] algorithm { statement ";" }

//ğŸŸ¨ some-equation :
//ğŸŸ¨    ( simple-expression "=" expression
//ğŸŸ¥      | if-equation
//ğŸŸ¥      | for-equation
//ğŸŸ¥      | connect-equation
//ğŸŸ¥      | when-equation
//ğŸŸ¥      | component-reference function-call-args
//ğŸŸ¥    )
//ğŸŸ¥    description
some_equation
    : simple_expression '='^ simple_expression
    ;

//ğŸŸ¥ statement :
//ğŸŸ¥    ( component-reference ( ":=" expression | function-call-args )
//ğŸŸ¥      | "(" output-expression-list ")" ":="
//ğŸŸ¥        component-reference function-call-args
//ğŸŸ¥      | break
//ğŸŸ¥      | return
//ğŸŸ¥      | if-statement
//ğŸŸ¥      | for-statement
//ğŸŸ¥      | while-statement
//ğŸŸ¥      | when-statement
//ğŸŸ¥    )
//ğŸŸ¥    description

//ğŸŸ¥ if-equation :
//ğŸŸ¥    if expression then
//ğŸŸ¥      { some-equation ";" }
//ğŸŸ¥    { elseif expression then
//ğŸŸ¥      { some-equation ";" }
//ğŸŸ¥    }
//ğŸŸ¥    [ else
//ğŸŸ¥      { some-equation ";" }
//ğŸŸ¥    ]
//ğŸŸ¥    end if

//ğŸŸ¥ if-statement :
//ğŸŸ¥    if expression then
//ğŸŸ¥      { statement ";" }
//ğŸŸ¥    { elseif expression then
//ğŸŸ¥      { statement ";" }
//ğŸŸ¥    }
//ğŸŸ¥    [ else
//ğŸŸ¥      { statement ";" }
//ğŸŸ¥    ]
//ğŸŸ¥    end if

//ğŸŸ¥ for-equation :
//ğŸŸ¥    for for-indices loop
//ğŸŸ¥      { some-equation ";" }
//ğŸŸ¥    end for

//ğŸŸ¥ for-statement :
//ğŸŸ¥    for for-indices loop
//ğŸŸ¥      { statement ";" }
//ğŸŸ¥    end for

//ğŸŸ¥ for-indices :
//ğŸŸ¥    for-index { "," for-index }

//ğŸŸ¥ for-index :
//ğŸŸ¥    IDENT [ in expression ]

//ğŸŸ¥ while-statement :
//ğŸŸ¥    while expression loop
//ğŸŸ¥      { statement ";" }
//ğŸŸ¥    end while

//ğŸŸ¥ when-equation :
//ğŸŸ¥    when expression then
//ğŸŸ¥      { some-equation ";" }
//ğŸŸ¥    { elsewhen expression then
//ğŸŸ¥      { some-equation ";" }
//ğŸŸ¥    }
//ğŸŸ¥    end when

//ğŸŸ¥ when-statement :
//ğŸŸ¥    when expression then
//ğŸŸ¥      { statement ";" }
//ğŸŸ¥    { elsewhen expression then
//ğŸŸ¥      { statement ";" }
//ğŸŸ¥    }
//ğŸŸ¥    end when

//ğŸŸ¥ connect-equation :
//ğŸŸ¥    connect "(" component-reference "," component-reference ")"

//=============================================================================
// A.2.7 Expressions
// âœ…: Implemented,  ğŸŸ¥: Not-Implemented, ğŸŸ¨: Partial

//ğŸŸ¥ expression :
//ğŸŸ¥    simple-expression
//ğŸŸ¥    | if expression then expression
//ğŸŸ¥      { elseif expression then expression }
//ğŸŸ¥      else expression

//âœ… simple-expression :
//âœ…    logical-expression [ ":" logical-expression [ ":" logical-expression ] ]
simple_expression
    : logical_expression [ ':'^ logical_expression [ ':'^ logical_expression ] ]
    ;

//âœ… logical-expression :
//âœ…    logical-term { or logical-term }
logical_expression
    : logical_term { or^ logical_term }
    ;

//âœ… logical-term :
//âœ…    logical-factor { and logical-factor }
logical_term
    : logical_factor { and^ logical_factor }
    ;

//âœ… logical-factor :
//âœ…    [ not ] relation
logical_factor
    : [ not ] relation
    ;

//âœ… relation :
//âœ…    arithmetic-expression [ relational-operator arithmetic-expression ]
relation
    : arithmetic_expression [ relational_operator arithmetic_expression ]
    ;

//âœ… relational-operator :
//âœ…    "<" | "<=" | ">" | ">=" | "==" | "<>"
relational_operator
    : '<'
    | '<='
    | '>'
    | '>='
    | '=='
    | '<>'
    ;

//âœ… arithmetic-expression :
//âœ…    [ add-operator ] term { add-operator term }
arithmetic_expression
    : [ add_operator ] term { add_operator term }
    ;

//âœ… add-operator :
//âœ…    "+" | "-" | ".+" | ".-"
add_operator: 
    '+' | '-' | '.+' | '.-'
    ;

//âœ… term :
//âœ…    factor { mul-operator factor }
term
    : factor { mul_operator factor }
    ;

//âœ… mul-operator :
//âœ…    "*" | "/" | ".*" | "./"
mul_operator:
    '*' | '/' | '.*' | './'
    ;

//âœ… factor :
//âœ…    primary [ ( "^" | ".^" ) primary ]
factor
    : primary { ( '^' | '.^' ) primary }
    ;

//ğŸŸ¨ primary :
//ğŸŸ¨    UNSIGNED-NUMBER
//ğŸŸ¥    | STRING
//ğŸŸ¥    | false
//ğŸŸ¥    | true
//ğŸŸ¥    | ( component-reference | der | initial | pure ) function-call-args
//âœ…    | component-reference
//ğŸŸ¥    | "(" output-expression-list ")" [ ( array-subscripts | "." IDENT ) ]
//ğŸŸ¥    | "[" expression-list { ";" expression-list } "]"
//ğŸŸ¥    | "{" array-arguments "}"
//ğŸŸ¥    | end
primary
    : unsigned_integer
    | component_reference
    ;

//ğŸŸ¥ UNSIGNED-NUMBER :
//ğŸŸ¥    UNSIGNED-INTEGER | UNSIGNED-REAL

//ğŸŸ¥ type-specifier :
//ğŸŸ¥    ["."] name
type_specifier
    : [ '.' ] name
    ;

//âœ… name :
//âœ…    IDENT { "." IDENT }
name
    : ident { '.'^ ident }
    ;

//ğŸŸ¨ component-reference :
//ğŸŸ¨    [ "." ] IDENT [ array-subscripts ] { "." IDENT [ array-subscripts ] }
component_reference
    : [ '.' ] ident { '.' ident }
    ;

//ğŸŸ¥ result-reference :
//ğŸŸ¥    component-reference
//ğŸŸ¥    | der "(" component-reference [ "," UNSIGNED-INTEGER ] ")"

//ğŸŸ¥ function-call-args :
//ğŸŸ¥    "(" [ function-arguments ] ")"

//ğŸŸ¥ function-arguments :
//ğŸŸ¥    expression [ "," function-arguments-non-first | for for-indices ]
//ğŸŸ¥    | function-partial-application [ "," function-arguments-non-first ]
//ğŸŸ¥    | named-arguments

//ğŸŸ¥ function-arguments-non-first :
//ğŸŸ¥    function-argument [ "," function-arguments-non-first ]
//ğŸŸ¥    | named-arguments

//ğŸŸ¥ array-arguments :
//ğŸŸ¥    expression [ "," array-arguments-non-first | for for-indices ]

//ğŸŸ¥ array-arguments-non-first :
//ğŸŸ¥    expression [ "," array-arguments-non-first ]

//ğŸŸ¥ named-arguments: named-argument [ "," named-arguments ]

//ğŸŸ¥ named-argument: IDENT "=" function-argument

//ğŸŸ¥ function-argument :
//ğŸŸ¥    function-partial-application | expression

//ğŸŸ¥ function-partial-application :
//ğŸŸ¥    function type-specifier "(" [ named-arguments ] ")"

//ğŸŸ¥ output-expression-list :
//ğŸŸ¥    [ expression ] { "," [ expression ] }

//ğŸŸ¥ expression-list :
//ğŸŸ¥    expression { "," expression }

//ğŸŸ¥ array-subscripts :
//ğŸŸ¥    "[" subscript { "," subscript } "]"

//ğŸŸ¥ subscript :
//ğŸŸ¥    ":" | expression

//ğŸŸ¥ description :
//ğŸŸ¥    description-string [ annotation-clause ]

//ğŸŸ¥ description-string :
//ğŸŸ¥    [ STRING { "+" STRING } ]

//ğŸŸ¥ annotation-clause :
//ğŸŸ¥    annotation class-modification
