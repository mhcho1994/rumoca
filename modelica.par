%start stored_definition
%title "Modelica grammar"
%comment "Modelica grammar 3.7-dev for `parol`"
%line_comment "//"
%t_type crate::modelica_grammar::OwnedToken
%nt_type stored_definition = crate::modelica_grammar::StoredDefinition
%nt_type class_definition = crate::modelica_grammar::ClassDefinition
%nt_type class_prefixes = crate::modelica_grammar::ClassPrefixes
%nt_type class_specifier = crate::modelica_grammar::ClassSpecifier
%nt_type long_class_specifier = crate::modelica_grammar::ClassSpecifier
%nt_type composition = crate::modelica_grammar::Composition
%nt_type element_list = crate::modelica_grammar::ElementList
%nt_type element = crate::modelica_grammar::Element
%nt_type component_clause = crate::modelica_grammar::ComponentClause
%nt_type component_list = crate::modelica_grammar::ComponentList
%nt_type component_declaration = crate::modelica_grammar::ComponentDeclaration
%nt_type declaration = crate::modelica_grammar::Declaration
%nt_type type_prefix = crate::modelica_grammar::TypePrefix
%nt_type type_specifier = crate::modelica_grammar::TypeSpecifier
%nt_type equation_section = crate::modelica_grammar::EquationSection
%nt_type ident = crate::modelica_grammar::Ident
%nt_type some_equation = crate::modelica_grammar::Equation
%nt_type simple_expression = crate::modelica_grammar::SimpleExpression
%nt_type logical_expression = crate::modelica_grammar::LogicalExpression
%nt_type logical_term = crate::modelica_grammar::LogicalTerm
%nt_type logical_factor = crate::modelica_grammar::LogicalFactor
%nt_type relation = crate::modelica_grammar::Relation
%nt_type relational_operator = crate::modelica_grammar::RelationalOperator
%nt_type arithmetic_expression = crate::modelica_grammar::ArithmeticExpression
%nt_type add_operator = crate::modelica_grammar::AddOperator
%nt_type term = crate::modelica_grammar::Term
%nt_type mul_operator = crate::modelica_grammar::MulOperator
%nt_type factor = crate::modelica_grammar::Factor
%nt_type primary = crate::modelica_grammar::Primary
%nt_type component_reference = crate::modelica_grammar::ComponentReference
%nt_type unsigned_integer = crate::modelica_grammar::UnsignedInteger
%nt_type name = crate::modelica_grammar::Name

%%
//=============================================================================
// 2.3.3 Modelica Keywords

// algorithm: 'algorithm';
and: 'and';
// annotation: 'annotation';
block: 'block';
// break: 'break';
class: 'class';
// connect: 'connect';
connector: 'connector';
constant: 'constant';
// constrainedby: 'constrainedby';
// der: 'der';
discrete: 'discrete';
// each: 'each';
// else: 'else';
// elseif: 'elseif';
// elsewhen: 'elsewhen';
encapsulated: 'encapsulated';
end: 'end';
// enumeration: 'enumeration';
equation: 'equation';
expandable: 'expandable';
// extends: 'extends';
// external: 'external';
// false: 'false';
final: 'final';
flow: 'flow';
// for: 'for';
function: 'function';
// if: 'if';
// import: 'import';
impure: 'impure';
// in: 'in';
initial: 'initial';
// inner: 'inner';
input: 'input';
// loop: 'loop';
model: 'model';
not: 'not';
operator: 'operator';
or: 'or';
// outer: 'outer';
output: 'output';
package: 'package';
parameter: 'parameter';
// partial: 'partial';
// protected: 'protected';
// public: 'public';
pure: 'pure';
record: 'record';
// redeclare: 'redeclare';
// replaceable: 'replaceable';
// return: 'return';
stream: 'stream';
// then: 'then';
// true: 'true';
type: 'type';
// when: 'when';
// while: 'while';
within: 'within';

//=============================================================================
// A.1 Lexical conventions
// IDENT = NON-DIGIT { DIGIT | NON-DIGIT } | Q-IDENT
ident
    : /[A-Za-z][A-Za-z0-9_]*/
    ;
// Q-IDENT = "'" { Q-CHAR | S-ESCAPE } "'"
// NON-DIGIT = "_" | letters "a" 
//  "z" | letters "A" 
//  "Z"
// DIGIT = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
// Q-CHAR = NON-DIGIT | DIGIT | "!" | "#" | "$" | "%" | "&" | "(" | ")"
//    | "*" | "+" | "," | "-" | "." | "/" | ":" | ";" | "<" | ">" | "="
//    | "?" | "@" | "[" | "]" | "^" | "{" | "}" | "|" | "~" | " " | """
// S-ESCAPE = "\'" | "\"" | "\?" | "\\"
//    | "\a" | "\b" | "\f" | "\n" | "\r" | "\t" | "\v"
// STRING = """ { S-CHAR | S-ESCAPE } """
// S-CHAR = see below

// UNSIGNED-INTEGER = DIGIT { DIGIT }
unsigned_integer
    : /[0-9]+/
    ;
// UNSIGNED-REAL =
//    UNSIGNED-INTEGER  "." [ UNSIGNED-INTEGER ]
//    | UNSIGNED_INTEGER [ "." [ UNSIGNED_INTEGER ] ]
//      ( "e" | "E" ) [ "+" | "-" ] UNSIGNED-INTEGER
//    | "."  UNSIGNED-INTEGER [ ( "e" | "E" ) [ "+" | "-" ] UNSIGNED-INTEGER ]


//=============================================================================
// A.2.1 Stored Definition â€“ Within
// âœ…: Implemented,  ðŸŸ¥: Not-Implemented, ðŸŸ¨: Partial

//âœ… stored-definition :
//âœ…    [ within [ name ] ";" ]
//âœ…    { [ final ] class-definition ";" }
stored_definition :
    [ within [ name ] ';' ]
    { [ final ] class_definition ';' }
    ;

//=============================================================================
// A.2.2 Class Definition
// âœ…: Implemented,  ðŸŸ¥: Not-Implemented, ðŸŸ¨: Partial

//âœ… class-definition :
//âœ…    [ encapsulated ] class-prefixes class-specifier
class_definition :
    [ encapsulated ] class_prefixes class_specifier
    ;

//âœ… class-prefixes :
//âœ…    [ partial ]
//âœ…    ( class
//âœ…      | model
//âœ…      | [ operator ] record
//âœ…      | block
//âœ…      | [ expandable ] connector
//âœ…      | type
//âœ…      | package
//âœ…      | [ pure | impure ] [ operator ] function
//âœ…      | operator
//âœ…    )
class_prefixes :
    [ 'partial' ]
    ( class
        | model
        | [ operator ] record
        | block
        | [ expandable ] connector
        | type
        | package
        | [ pure | impure ] [ operator ] function
        | operator
    )
    ;

//ðŸŸ¨ class-specifier :
//ðŸŸ¨    long-class-specifier
//ðŸŸ¥    | short-class-specifier
//ðŸŸ¥    | der-class-specifier
class_specifier :
    long_class_specifier
    ;

//ðŸŸ¨ long-class-specifier :
//ðŸŸ¨    IDENT description-string composition end IDENT
//ðŸŸ¥    | extends IDENT [ class-modification ] description-string composition end IDENT
long_class_specifier :
    ident@name composition end^ ident
    ;

//ðŸŸ¥ short-class-specifier :
//ðŸŸ¥    IDENT "=" base-prefix type-specifier [ array-subscripts ]
//ðŸŸ¥    [ class-modification ] description
//ðŸŸ¥    | IDENT "=" enumeration "(" ( [ enum-list ] | ":" ) ")" description

//ðŸŸ¥ der-class-specifier :
//ðŸŸ¥    IDENT "=" der "(" type-specifier "," IDENT { "," IDENT } ")" description

//ðŸŸ¥ base-prefix :
//ðŸŸ¥    [ input | output ]

//ðŸŸ¥ enum-list :
//ðŸŸ¥    enumeration-literal { "," enumeration-literal }

//ðŸŸ¥ enumeration-literal :
//ðŸŸ¥    IDENT description

//ðŸŸ¥ composition :
//ðŸŸ¥    element-list
//ðŸŸ¥    { public element-list
//ðŸŸ¥      | protected element-list
//ðŸŸ¥      | equation-section
//ðŸŸ¥      | algorithm-section
//ðŸŸ¥    }
//ðŸŸ¥    [ external [ language-specification ]
//ðŸŸ¥      [ external-function-call ] [ annotation-clause ] ";"
//ðŸŸ¥    ]
//ðŸŸ¥    [ annotation-clause ";" ]
composition :
    element_list { equation_section }
    ;

//ðŸŸ¥ language-specification :
//ðŸŸ¥    STRING

//ðŸŸ¥ external-function-call :
//ðŸŸ¥    [ component-reference "=" ]
//ðŸŸ¥    IDENT "(" [ expression-list ] ")"

element_list :
    { element ';'^ }
    ;

//ðŸŸ¥ element :
//ðŸŸ¥    import-clause
//ðŸŸ¥    | extends-clause
//ðŸŸ¥    | [ redeclare ]
//ðŸŸ¥      [ final ]
//ðŸŸ¥      [ inner ] [ outer ]
//ðŸŸ¥      ( class-definition
//ðŸŸ¥        | component-clause
//ðŸŸ¥        | replaceable ( class-definition | component-clause )
//ðŸŸ¥          [ constraining-clause description ]
//ðŸŸ¥      )
element :
    component_clause
    ;

//ðŸŸ¥ import-clause :
//ðŸŸ¥    import
//ðŸŸ¥    ( IDENT "=" name
//ðŸŸ¥      | name [ ".*" | "." ( "*" | "{" import-list "}" ) ]
//ðŸŸ¥    )
//ðŸŸ¥    description

//ðŸŸ¥ import-list :
//ðŸŸ¥    IDENT { "," IDENT }

//=============================================================================
// A.2.3 Extends
// âœ…: Implemented,  ðŸŸ¥: Not-Implemented, ðŸŸ¨: Partial

//ðŸŸ¥ extends-clause :
//ðŸŸ¥    extends type-specifier [ class-or-inheritance-modification ] [ annotation-clause ]

//ðŸŸ¥ constraining-clause :
//ðŸŸ¥    constrainedby type-specifier [ class-modification ]

//ðŸŸ¥ class-or-inheritance-modification :
//ðŸŸ¥    "(" [ argument-or-inheritance-modification-list ] ")"

//ðŸŸ¥ argument-or-inheritance-modification-list :
//ðŸŸ¥     ( argument | inheritance-modification ) { "," ( argument | inheritance-modification ) }

//ðŸŸ¥ inheritance-modification :
//ðŸŸ¥     break ( connect-equation | IDENT )

//-----------------------------------------------------------------------------
// A.2.4 Component Clause
// âœ…: Implemented,  ðŸŸ¥: Not-Implemented, ðŸŸ¨: Partial

//ðŸŸ¨ component-clause :
//ðŸŸ¨    type-prefix type-specifier [ array-subscripts ] component-list
component_clause :
    type_prefix type_specifier component_list
    ;

//âœ… type-prefix :
//âœ…    [ flow | stream ]
//âœ…    [ discrete | parameter | constant ]
//âœ…    [ input | output ]
type_prefix:
    [ flow | stream ]
    [ discrete | parameter | constant ]
    [ input | output ]
    ;

//âœ… component-list :
//âœ…    component-declaration { "," component-declaration }
component_list :
    component_declaration { ','^ component_declaration }
    ;

//ðŸŸ¨ component-declaration :
//ðŸŸ¨    declaration [ condition-attribute ] description
component_declaration :
    declaration
    ;

//ðŸŸ¥ condition-attribute :
//ðŸŸ¥    if expression

//ðŸŸ¨ declaration :
//ðŸŸ¨    IDENT [ array-subscripts ] [ modification ]
declaration :
    ident
    ;

//=============================================================================
// A.2.5 Modification
// âœ…: Implemented,  ðŸŸ¥: Not-Implemented, ðŸŸ¨: Partial

//ðŸŸ¥ modification :
//ðŸŸ¥    class-modification [ "=" modification-expression ]
//ðŸŸ¥    | "=" modification-expression

//ðŸŸ¥ modification-expression :
//ðŸŸ¥    expression
//ðŸŸ¥    | break

//ðŸŸ¥ class-modification :
//ðŸŸ¥    "(" [ argument-list ] ")"

//ðŸŸ¥ argument-list :
//ðŸŸ¥    argument { "," argument }

//ðŸŸ¥ argument :
//ðŸŸ¥    element-modification-or-replaceable
//ðŸŸ¥    | element-redeclaration

//ðŸŸ¥ element-modification-or-replaceable :
//ðŸŸ¥    [ each ] [ final ] ( element-modification | element-replaceable )

//ðŸŸ¥ element-modification :
//ðŸŸ¥    name [ modification ] description-string

//ðŸŸ¥ element-redeclaration :
//ðŸŸ¥    redeclare [ each ] [ final ]
//ðŸŸ¥    ( short-class-definition | component-clause1 | element-replaceable )

//ðŸŸ¥ element-replaceable :
//ðŸŸ¥    replaceable ( short-class-definition | component-clause1 )
//ðŸŸ¥    [ constraining-clause ]

//ðŸŸ¥ component-clause1 :
//ðŸŸ¥    type-prefix type-specifier component-declaration1

//ðŸŸ¥ component-declaration1 :
//ðŸŸ¥    declaration description

//ðŸŸ¥ short-class-definition :
//ðŸŸ¥    class-prefixes short-class-specifier

//=============================================================================
// A.2.6 Equations
// âœ…: Implemented,  ðŸŸ¥: Not-Implemented, ðŸŸ¨: Partial

//âœ… equation-section :
//âœ…    [ initial ] equation { some-equation ";" }
equation_section :
    [ initial ] equation^ { some_equation ';'^ }
    ;

//ðŸŸ¥ algorithm-section :
//ðŸŸ¥    [ initial ] algorithm { statement ";" }

//ðŸŸ¨ some-equation :
//ðŸŸ¨    ( simple-expression "=" expression
//ðŸŸ¥      | if-equation
//ðŸŸ¥      | for-equation
//ðŸŸ¥      | connect-equation
//ðŸŸ¥      | when-equation
//ðŸŸ¥      | component-reference function-call-args
//ðŸŸ¥    )
//ðŸŸ¥    description
some_equation
    : simple_expression '='^ simple_expression
    ;

//ðŸŸ¥ statement :
//ðŸŸ¥    ( component-reference ( ":=" expression | function-call-args )
//ðŸŸ¥      | "(" output-expression-list ")" ":="
//ðŸŸ¥        component-reference function-call-args
//ðŸŸ¥      | break
//ðŸŸ¥      | return
//ðŸŸ¥      | if-statement
//ðŸŸ¥      | for-statement
//ðŸŸ¥      | while-statement
//ðŸŸ¥      | when-statement
//ðŸŸ¥    )
//ðŸŸ¥    description

//ðŸŸ¥ if-equation :
//ðŸŸ¥    if expression then
//ðŸŸ¥      { some-equation ";" }
//ðŸŸ¥    { elseif expression then
//ðŸŸ¥      { some-equation ";" }
//ðŸŸ¥    }
//ðŸŸ¥    [ else
//ðŸŸ¥      { some-equation ";" }
//ðŸŸ¥    ]
//ðŸŸ¥    end if

//ðŸŸ¥ if-statement :
//ðŸŸ¥    if expression then
//ðŸŸ¥      { statement ";" }
//ðŸŸ¥    { elseif expression then
//ðŸŸ¥      { statement ";" }
//ðŸŸ¥    }
//ðŸŸ¥    [ else
//ðŸŸ¥      { statement ";" }
//ðŸŸ¥    ]
//ðŸŸ¥    end if

//ðŸŸ¥ for-equation :
//ðŸŸ¥    for for-indices loop
//ðŸŸ¥      { some-equation ";" }
//ðŸŸ¥    end for

//ðŸŸ¥ for-statement :
//ðŸŸ¥    for for-indices loop
//ðŸŸ¥      { statement ";" }
//ðŸŸ¥    end for

//ðŸŸ¥ for-indices :
//ðŸŸ¥    for-index { "," for-index }

//ðŸŸ¥ for-index :
//ðŸŸ¥    IDENT [ in expression ]

//ðŸŸ¥ while-statement :
//ðŸŸ¥    while expression loop
//ðŸŸ¥      { statement ";" }
//ðŸŸ¥    end while

//ðŸŸ¥ when-equation :
//ðŸŸ¥    when expression then
//ðŸŸ¥      { some-equation ";" }
//ðŸŸ¥    { elsewhen expression then
//ðŸŸ¥      { some-equation ";" }
//ðŸŸ¥    }
//ðŸŸ¥    end when

//ðŸŸ¥ when-statement :
//ðŸŸ¥    when expression then
//ðŸŸ¥      { statement ";" }
//ðŸŸ¥    { elsewhen expression then
//ðŸŸ¥      { statement ";" }
//ðŸŸ¥    }
//ðŸŸ¥    end when

//ðŸŸ¥ connect-equation :
//ðŸŸ¥    connect "(" component-reference "," component-reference ")"

//=============================================================================
// A.2.7 Expressions

//ðŸŸ¥ expression :
//ðŸŸ¥    simple-expression
//ðŸŸ¥    | if expression then expression
//ðŸŸ¥      { elseif expression then expression }
//ðŸŸ¥      else expression

//ðŸŸ¥ simple-expression :
//ðŸŸ¥    logical-expression [ ":" logical-expression [ ":" logical-expression ] ]
simple_expression
    : logical_expression [ ':'^ logical_expression [ ':'^ logical_expression ] ]
    ;

//ðŸŸ¥ logical-expression :
//ðŸŸ¥    logical-term { or logical-term }
logical_expression
    : logical_term { or^ logical_term }
    ;

//ðŸŸ¥ logical-term :
//ðŸŸ¥    logical-factor { and logical-factor }
logical_term
    : logical_factor { and^ logical_factor }
    ;

//ðŸŸ¥ logical-factor :
//ðŸŸ¥    [ not ] relation
logical_factor
    : [ not ] relation
    ;

//ðŸŸ¥ relation :
//ðŸŸ¥    arithmetic-expression [ relational-operator arithmetic-expression ]
relation
    : arithmetic_expression [ relational_operator arithmetic_expression ]
    ;

//ðŸŸ¥ relational-operator :
//ðŸŸ¥    "<" | "<=" | ">" | ">=" | "==" | "<>"
relational_operator
    : '<'
    | '<='
    | '>'
    | '>='
    | '=='
    | '<>'
    ;

//ðŸŸ¥ arithmetic-expression :
//ðŸŸ¥    [ add-operator ] term { add-operator term }
arithmetic_expression
    : [ add_operator ] term { add_operator term }
    ;

//ðŸŸ¥ add-operator :
//ðŸŸ¥    "+" | "-" | ".+" | ".-"
add_operator: 
    '+' | '-' | '.+' | '.-'
    ;

//ðŸŸ¥ term :
//ðŸŸ¥    factor { mul-operator factor }
term
    : factor { mul_operator factor }
    ;

//ðŸŸ¥ mul-operator :
//ðŸŸ¥    "*" | "/" | ".*" | "./"
mul_operator:
    '*' | '/' | '.*' | './'
    ;

//ðŸŸ¥ factor :
//ðŸŸ¥    primary [ ( "^" | ".^" ) primary ]
factor
    : primary { ( '^' | '.^' ) primary }
    ;

//ðŸŸ¥ primary :
//ðŸŸ¥    UNSIGNED-NUMBER
//ðŸŸ¥    | STRING
//ðŸŸ¥    | false
//ðŸŸ¥    | true
//ðŸŸ¥    | ( component-reference | der | initial | pure ) function-call-args
//ðŸŸ¥    | component-reference
//ðŸŸ¥    | "(" output-expression-list ")" [ ( array-subscripts | "." IDENT ) ]
//ðŸŸ¥    | "[" expression-list { ";" expression-list } "]"
//ðŸŸ¥    | "{" array-arguments "}"
//ðŸŸ¥    | end
primary
    : unsigned_integer
    | component_reference
    ;

//ðŸŸ¥ UNSIGNED-NUMBER :
//ðŸŸ¥    UNSIGNED-INTEGER | UNSIGNED-REAL

//ðŸŸ¥ type-specifier :
//ðŸŸ¥    ["."] name
type_specifier
    : [ '.' ] name
    ;

//ðŸŸ¥ name :
//ðŸŸ¥    IDENT { "." IDENT }
name
    : ident { '.'^ ident }
    ;

//ðŸŸ¥ component-reference :
//ðŸŸ¥    [ "." ] IDENT [ array-subscripts ] { "." IDENT [ array-subscripts ] }
component_reference
    : [ '.' ] ident { '.' ident }
    ;

//ðŸŸ¥ result-reference :
//ðŸŸ¥    component-reference
//ðŸŸ¥    | der "(" component-reference [ "," UNSIGNED-INTEGER ] ")"

//ðŸŸ¥ function-call-args :
//ðŸŸ¥    "(" [ function-arguments ] ")"

//ðŸŸ¥ function-arguments :
//ðŸŸ¥    expression [ "," function-arguments-non-first | for for-indices ]
//ðŸŸ¥    | function-partial-application [ "," function-arguments-non-first ]
//ðŸŸ¥    | named-arguments

//ðŸŸ¥ function-arguments-non-first :
//ðŸŸ¥    function-argument [ "," function-arguments-non-first ]
//ðŸŸ¥    | named-arguments

//ðŸŸ¥ array-arguments :
//ðŸŸ¥    expression [ "," array-arguments-non-first | for for-indices ]

//ðŸŸ¥ array-arguments-non-first :
//ðŸŸ¥    expression [ "," array-arguments-non-first ]

//ðŸŸ¥ named-arguments: named-argument [ "," named-arguments ]

//ðŸŸ¥ named-argument: IDENT "=" function-argument

//ðŸŸ¥ function-argument :
//ðŸŸ¥    function-partial-application | expression

//ðŸŸ¥ function-partial-application :
//ðŸŸ¥    function type-specifier "(" [ named-arguments ] ")"

//ðŸŸ¥ output-expression-list :
//ðŸŸ¥    [ expression ] { "," [ expression ] }

//ðŸŸ¥ expression-list :
//ðŸŸ¥    expression { "," expression }

//ðŸŸ¥ array-subscripts :
//ðŸŸ¥    "[" subscript { "," subscript } "]"

//ðŸŸ¥ subscript :
//ðŸŸ¥    ":" | expression

//ðŸŸ¥ description :
//ðŸŸ¥    description-string [ annotation-clause ]

//ðŸŸ¥ description-string :
//ðŸŸ¥    [ STRING { "+" STRING } ]

//ðŸŸ¥ annotation-clause :
//ðŸŸ¥    annotation class-modification
