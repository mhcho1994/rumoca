%start stored_definition
%title "Modelica grammar"
%comment "Modelica grammar 3.7-dev for `parol`"
%line_comment "//"
%t_type crate::ir::Token // %nt_type stored_definition = crate::modelica_grammar::StoredDefinition //%nt_type class_definition = crate::ir::ClassDefinition // %nt_type class_prefixes = crate::modelica_grammar::ClassPrefixes //%nt_type class_specifier = crate::modelica_grammar::ClassSpecifier //%nt_type long_class_specifier = crate::modelica_grammar::ClassSpecifier
%nt_type composition = crate::modelica_grammar::Composition
%nt_type element_list = crate::modelica_grammar::ElementList // %nt_type element = crate::modelica_grammar::Element // %nt_type component_clause = crate::modelica_grammar::ComponentClause
%nt_type component_list = crate::modelica_grammar::ComponentList // %nt_type component_declaration = crate::modelica_grammar::ComponentDeclaration // %nt_type declaration = crate::modelica_grammar::Declaration // %nt_type type_prefix = crate::modelica_grammar::TypePrefix // %nt_type type_specifier = crate::modelica_grammar::TypeSpecifier
%nt_type equation_section = crate::modelica_grammar::EquationSection
%nt_type algorithm_section = crate::modelica_grammar::AlgorithmSection
%nt_type some_equation = crate::ir::Equation
%nt_type simple_expression = crate::ir::Expression
%nt_type expression = crate::ir::Expression
%nt_type logical_expression = crate::ir::Expression
%nt_type logical_term = crate::ir::Expression
%nt_type logical_factor = crate::ir::Expression
%nt_type relation = crate::ir::Expression // %nt_type relational_operator = crate::modelica_grammar::RelationalOperator
%nt_type arithmetic_expression = crate::ir::Expression // %nt_type add_operator = crate::modelica_grammar::AddOperator
%nt_type term = crate::ir::Expression // %nt_type mul_operator = crate::modelica_grammar::MulOperator
%nt_type factor = crate::ir::Expression
%nt_type primary = crate::ir::Expression
%nt_type component_reference = crate::ir::ComponentReference
%nt_type name = crate::ir::Name
%nt_type statement = crate::ir::Statement
%nt_type array_subscripts = crate::modelica_grammar::ArraySubscripts
%nt_type subscript = crate::ir::Subscript // terminals
%nt_type ident = crate::ir::Token
%nt_type unsigned_integer = crate::ir::Token
%nt_type unsigned_real = crate::ir::Token

%%

//=============================================================================
// 2.3.3 Modelica Keywords
algorithm
    : 'algorithm'
    ;

and : 'and'
    ;

annotation
    : 'annotation'
    ;

block
    : 'block'
    ;

break
    : 'break'
    ;

class
    : 'class'
    ;

connect
    : 'connect'
    ;

connector
    : 'connector'
    ;

constant
    : 'constant'
    ;

constrainedby
    : 'constrainedby'
    ;

der : 'der'
    ;

discrete
    : 'discrete'
    ;

each: 'each'
    ;

else: 'else'
    ;

elseif
    : 'elseif'
    ;

elsewhen
    : 'elsewhen'
    ;

encapsulated
    : 'encapsulated'
    ;

end : 'end'
    ;

enumeration
    : 'enumeration'
    ;

equation
    : 'equation'
    ;

expandable
    : 'expandable'
    ;

extends
    : 'extends'
    ;

external
    : 'external'
    ;

false
    : 'false'
    ;

final
    : 'final'
    ;

flow: 'flow'
    ;

for : 'for'
    ;

function
    : 'function'
    ;

if  : 'if'
    ;

import
    : 'import'
    ;

impure
    : 'impure'
    ;

in  : 'in'
    ;

initial
    : 'initial'
    ;

inner
    : 'inner'
    ;

input
    : 'input'
    ;

loop: 'loop'
    ;

model
    : 'model'
    ;

not : 'not'
    ;

operator
    : 'operator'
    ;

or  : 'or'
    ;

outer
    : 'outer'
    ;

output
    : 'output'
    ;

package
    : 'package'
    ;

parameter
    : 'parameter'
    ;

partial
    : 'partial'
    ;

protected
    : 'protected'
    ;

public
    : 'public'
    ;

pure: 'pure'
    ;

record
    : 'record'
    ;

redeclare
    : 'redeclare'
    ;

replaceable
    : 'replaceable'
    ;

return
    : 'return'
    ;

stream
    : 'stream'
    ;

then: 'then'
    ;

true: 'true'
    ;

type: 'type'
    ;

when: 'when'
    ;

while
    : 'while'
    ;

within
    : 'within'
    ;

//=============================================================================
// A.1 Lexical conventions
// IDENT = NON-DIGIT { DIGIT | NON-DIGIT } | Q-IDENT
ident
    : /[_a-zA-Z][_a-zA-Z0-9]*/
    ;

// Q-IDENT = "'" { Q-CHAR | S-ESCAPE } "'"
// NON-DIGIT = "_" | letters "a"..."z" | letters "A"..."Z"
// DIGIT = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
// Q-CHAR = NON-DIGIT | DIGIT | "!" | "#" | "$" | "%" | "&" | "(" | ")"
//    | "*" | "+" | "," | "-" | "." | "/" | ":" | ";" | "<" | ">" | "="
//    | "?" | "@" | "[" | "]" | "^" | "{" | "}" | "|" | "~" | " " | """
// S-ESCAPE = "\'" | "\"" | "\?" | "\\"
//    | "\a" | "\b" | "\f" | "\n" | "\r" | "\t" | "\v"
// STRING = """ { S-CHAR | S-ESCAPE } """
string
    : /"[\w]*"/
    ;

// S-CHAR is any member of the Unicode character set
// (https://unicode.org; see section 13.4 for storing as UTF-8 on files)
// except double-quote â€˜â€â€™, and backslash â€˜\â€™.
// UNSIGNED-INTEGER = DIGIT { DIGIT }
unsigned_integer
    : /[0-9]+/
    ;

// UNSIGNED-REAL =
//    UNSIGNED-INTEGER  "." [ UNSIGNED-INTEGER ]
//    | UNSIGNED_INTEGER [ "." [ UNSIGNED_INTEGER ] ]
//      ( "e" | "E" ) [ "+" | "-" ] UNSIGNED-INTEGER
//    | "."  UNSIGNED-INTEGER [ ( "e" | "E" ) [ "+" | "-" ] UNSIGNED-INTEGER ]
unsigned_real
    : /[0-9]+\.[0-9]+/@decimal
    | /[0-9]+\.([0-9]+)?([eE][+-]?[0-9]+)?/@scientific
    | /\.[0-9]+([eE][+-]?[0-9]+)?/@scientific2
    ;

//=============================================================================
// A.2.1 Stored Definition â€“ Within
// âœ…: Implemented,  ğŸŸ¥: Not-Implemented, ğŸŸ¨: Partial
//âœ… stored-definition :
//âœ…    [ within [ name ] ";" ]
//âœ…    { [ final ] class-definition ";" }
stored_definition
    : [ within^ [ name ] ';'^ ] { [ final ] class_definition ';'^ }
    ;

//=============================================================================
// A.2.2 Class Definition
// âœ…: Implemented,  ğŸŸ¥: Not-Implemented, ğŸŸ¨: Partial
//âœ… class-definition :
//âœ…    [ encapsulated ] class-prefixes class-specifier
class_definition
    : [ encapsulated ] class_prefixes class_specifier
    ;

//âœ… class-prefixes :
//âœ…    [ partial ]
//âœ…    ( class
//âœ…      | model
//âœ…      | [ operator ] record
//âœ…      | block
//âœ…      | [ expandable ] connector
//âœ…      | type
//âœ…      | package
//âœ…      | [ pure | impure ] [ operator ] function
//âœ…      | operator
//âœ…    )
class_prefixes
    : [ partial ]
      ( class | model | [ operator ] record | block | [ expandable ] connector | type | package | [ pure | impure ] [ operator ] function | operator )
    ;

//âœ… class-specifier :
//âœ…    long-class-specifier
//âœ…    | short-class-specifier
//âœ…    | der-class-specifier
class_specifier
    : long_class_specifier
    | short_class_specifier
    | der_class_specifier
    ;

//âœ… long-class-specifier :
//âœ…    IDENT description-string composition end IDENT
//âœ…    | extends IDENT [ class-modification ] description-string composition end IDENT
long_class_specifier
    : ident@name composition end^ ident
    | extends^ name [ class_modification ] description_string
      // composition (TODO: won't compile if added)
      end^ ident
    ;

//âœ… short-class-specifier :
//âœ…    IDENT "=" base-prefix type-specifier [ array-subscripts ]
//âœ…    [ class-modification ] description
//âœ…    | IDENT "=" enumeration "(" ( [ enum-list ] | ":" ) ")" description
short_class_specifier
    : ident '='^ base_prefix type_specifier [ array_subscripts ] [ class_modification ] description
    | ident '='^ enumeration '('^ ( [ enum_list ] | ':'^ ) ')'^ description
    ;

//âœ… der-class-specifier :
//âœ…    IDENT "=" der "(" type-specifier "," IDENT { "," IDENT } ")" description
der_class_specifier
    : ident '=' der '('^ type_specifier ','^ ident { ','^ ident } ')'^ description
    ;

//âœ… base-prefix :
//âœ…    [ input | output ]
base_prefix
    : [ input | output ]
    ;

//âœ… enum-list :
//âœ…    enumeration-literal { "," enumeration-literal }
enum_list
    : enumeration_literal { ','^ enumeration_literal }
    ;

//âœ… enumeration-literal :
//âœ…    IDENT description
enumeration_literal
    : ident description
    ;

//âœ… composition :
//âœ…    element-list
//âœ…    { public element-list
//âœ…      | protected element-list
//âœ…      | equation-section
//âœ…      | algorithm-section
//âœ…    }
//âœ…    [ external [ language-specification ]
//âœ…      [ external-function-call ] [ annotation-clause ] ";"
//âœ…    ]
//âœ…    [ annotation-clause ";" ]
composition
    : element_list
      { public element_list | protected element_list | equation_section | algorithm_section }
      [ external^ [ language_specification ] [ external_function_call ] [ annotation_clause ] ';'^ ]
      [ annotation_clause ';'^ ]
    ;

//âœ… language-specification :
//âœ…    STRING
language_specification
    : string
    ;

//âœ… external-function-call :
//âœ…    [ component-reference "=" ]
//âœ…    IDENT "(" [ expression-list ] ")"
external_function_call
    : [ component_reference '='^ ] ident '('^ [ expression_list ] ')'^
    ;

//âœ… element-list :
//âœ…    { element ";" }
element_list
    : { element ';' }
    ;

//âœ… element :
//âœ…    import-clause
//âœ…    | extends-clause
//âœ…    | [ redeclare ]
//âœ…      [ final ]
//âœ…      [ inner ] [ outer ]
//âœ…      ( class-definition
//âœ…        | component-clause
//âœ…        | replaceable ( class-definition | component-clause )
//âœ…          [ constraining-clause description ]
//âœ…      )
element
    : import_clause
    | extends_clause
    | [ redeclare ] [ final ] [ inner ] [ outer ] ( class_definition | component_clause )
    | replaceable ( class_definition | component_clause ) [ constraining_clause description ]
    ;

//âœ… import-clause :
//âœ…    import
//âœ…    ( IDENT "=" name
//âœ…      | name [ ".*" | "." ( "*" | "{" import-list "}" ) ]
//âœ…    )
//âœ…    description
import_clause
    : import ( ident '='^ name | name [ '.*' | '.'^ ( '*' | '{' import_list '}' ) ] ) description
    ;

//âœ… import-list :
//âœ…    IDENT { "," IDENT }
import_list
    : ident { ','^ ident }
    ;

//=============================================================================
// A.2.3 Extends
// âœ…: Implemented,  ğŸŸ¥: Not-Implemented, ğŸŸ¨: Partial
//âœ… extends-clause :
//âœ…    extends type-specifier [ class-or-inheritance-modification ] [ annotation-clause ]
extends_clause
    : extends^ type_specifier [ class_or_inheritance_modification ] [ annotation_clause ]
    ;

//âœ… constraining-clause :
//âœ…    constrainedby type-specifier [ class-modification ]
constraining_clause
    : constrainedby^ type_specifier [ class_modification ]
    ;

//âœ… class-or-inheritance-modification :
//âœ…    "(" [ argument-or-inheritance-modification-list ] ")"
class_or_inheritance_modification
    : '('^ [ argument_or_inheritance_modification_list ] ')'^
    ;

//âœ… argument-or-inheritance-modification-list :
//âœ…     ( argument | inheritance-modification ) { "," ( argument | inheritance-modification ) }
argument_or_inheritance_modification_list
    : ( argument | inheritance_modification ) { ','^ ( argument | inheritance_modification ) }
    ;

//âœ… inheritance-modification :
//âœ…     break ( connect-equation | IDENT )
inheritance_modification
    : break^ ( connect_equation | ident )
    ;

//-----------------------------------------------------------------------------
// A.2.4 Component Clause
// âœ…: Implemented,  ğŸŸ¥: Not-Implemented, ğŸŸ¨: Partial
//âœ… component-clause :
//âœ…    type-prefix type-specifier [ array-subscripts ] component-list
component_clause
    : type_prefix type_specifier [ array_subscripts ] component_list
    ;

//âœ… type-prefix :
//âœ…    [ flow | stream ]
//âœ…    [ discrete | parameter | constant ]
//âœ…    [ input | output ]
type_prefix
    : [ flow | stream ] [ discrete | parameter | constant ] [ input | output ]
    ;

//âœ… component-list :
//âœ…    component-declaration { "," component-declaration }
component_list
    : component_declaration { ','^ component_declaration }
    ;

//âœ… component-declaration :
//âœ…    declaration [ condition-attribute ] description
component_declaration
    : declaration // [ condition_attribute ]
      description
    ;

//âœ… condition-attribute :
//âœ…    if expression
// condition_attribute :
//     if^ expression
//     ;
//âœ… declaration :
//âœ…    IDENT [ array-subscripts ] [ modification ]
declaration
    : ident [ array_subscripts ] // [ modification ]
    ;

//=============================================================================
// A.2.5 Modification
// âœ…: Implemented,  ğŸŸ¥: Not-Implemented, ğŸŸ¨: Partial
//âœ… modification :
//âœ…    class-modification [ "=" modification-expression ]
//âœ…    | "=" modification-expression
modification
    : class_modification [ '='^ modification_expression ]
    | '='^ modification_expression
    ;

//âœ… modification-expression :
//âœ…    expression
//âœ…    | break
modification_expression
    : expression
    | break
    ;

//âœ… class-modification :
//âœ…    "(" [ argument-list ] ")"
class_modification
    : '('^ [ argument_list ] ')'^
    ;

//âœ… argument-list :
//âœ…    argument { "," argument }
argument_list
    : argument { ','^ argument }
    ;

//âœ… argument :
//âœ…    element-modification-or-replaceable
//âœ…    | element-redeclaration
argument
    : element_modification_or_replaceable
    | element_redeclaration
    ;

//âœ… element-modification-or-replaceable :
//âœ…    [ each ] [ final ] ( element-modification | element-replaceable )
element_modification_or_replaceable
    : [ each ] [ final ] ( element_modification | element_replaceable )
    ;

//âœ… element-modification :
//âœ…    name [ modification ] description-string
element_modification
    : name [ modification ] description_string
    ;

//âœ… element-redeclaration :
//âœ…    redeclare [ each ] [ final ]
//âœ…    ( short-class-definition | component-clause1 | element-replaceable )
element_redeclaration
    : redeclare [ each ] [ final ]
      ( short_class_definition | component_clause1 | element_replaceable )
    ;

//âœ… element-replaceable :
//âœ…    replaceable ( short-class-definition | component-clause1 )
//âœ…    [ constraining-clause ]
element_replaceable
    : replaceable ( short_class_definition | component_clause1 ) [ constraining_clause ]
    ;

//âœ… component-clause1 :
//âœ…    type-prefix type-specifier component-declaration1
component_clause1
    : type_prefix type_specifier component_declaration1
    ;

//âœ… component-declaration1 :
//âœ…    declaration description
component_declaration1
    : declaration description
    ;

//âœ… short-class-definition :
//âœ…    class-prefixes short-class-specifier
short_class_definition
    : class_prefixes short_class_specifier
    ;

//=============================================================================
// A.2.6 Equations
// âœ…: Implemented,  ğŸŸ¥: Not-Implemented, ğŸŸ¨: Partial
//âœ… equation-section :
//âœ…    [ initial ] equation { some-equation ";" }
equation_section
    : [ initial^ ] equation^ { some_equation ';'^ }
    ;

//âœ… algorithm-section :
//âœ…    [ initial ] algorithm { statement ";" }
algorithm_section
    : [ initial^ ] algorithm^ { statement ';'^ }
    ;

//âœ… some-equation :
//âœ…    ( simple-expression "=" expression
//âœ…      | if-equation
//âœ…      | for-equation
//âœ…      | connect-equation
//âœ…      | when-equation
//âœ…      | component-reference function-call-args
//âœ…    )
//âœ…    description
some_equation
    : 
      ( simple_expression '='^ expression | if_equation | for_equation | connect_equation | when_equation )
      /*component_reference function_call_args*/ description
    ;

//âœ… statement :
//âœ…    ( component-reference ( ":=" expression | function-call-args )
//âœ…      | "(" output-expression-list ")" ":="
//âœ…        component-reference function-call-args
//âœ…      | break
//âœ…      | return
//âœ…      | if-statement
//âœ…      | for-statement
//âœ…      | while-statement
//âœ…      | when-statement
//âœ…    )
//âœ…    description
statement
    : 
      ( component_reference ( ":="^ expression ) | break | return | if_statement | for_statement | while_statement | when_statement )
      description
    ;

//âœ… if-equation :
//âœ…    if expression then
//âœ…      { some-equation ";" }
//âœ…    { elseif expression then
//âœ…      { some-equation ";" }
//âœ…    }
//âœ…    [ else
//âœ…      { some-equation ";" }
//âœ…    ]
//âœ…    end if
if_equation
    : if^ expression then^ { some_equation ';'^ } { elseif^ expression then^ { some_equation ';'^ } }
      [ else^ { some_equation ';'^ } ] end^ if
    ;

//âœ… if-statement :
//âœ…    if expression then
//âœ…      { statement ";" }
//âœ…    { elseif expression then
//âœ…      { statement ";" }
//âœ…    }
//âœ…    [ else
//âœ…      { statement ";" }
//âœ…    ]
//âœ…    end if
if_statement
    : if^ expression then^ { statement ';'^ } { elseif^ expression then^ { statement ';'^ } }
      [ else^ { statement ';'^ } ] end^ if
    ;

//âœ… for-equation :
//âœ…    for for-indices loop
//âœ…      { some-equation ";" }
//âœ…    end for
for_equation
    : for^ for_indices loop^ { some_equation ';'^ } end^ for
    ;

//âœ… for-statement :
//âœ…    for for-indices loop
//âœ…      { statement ";" }
//âœ…    end for
for_statement
    : for^ for_indices loop^ { statement ';'^ } end^ for
    ;

//âœ… for-indices :
//âœ…    for-index { "," for-index }
for_indices
    : for_index { ','^ for_index }
    ;

//âœ… for-index :
//âœ…    IDENT [ in expression ]
for_index
    : ident [ in^ expression ]
    ;

//âœ… while-statement :
//âœ…    while expression loop
//âœ…      { statement ";" }
//âœ…    end while
while_statement
    : while^ expression loop^ { statement ';'^ } end^ while
    ;

//âœ… when-equation :
//âœ…    when expression then
//âœ…      { some-equation ";" }
//âœ…    { elsewhen expression then
//âœ…      { some-equation ";" }
//âœ…    }
//âœ…    end when
when_equation
    : when^ expression then^ { some_equation ';'^ }
      { elsewhen^ expression then^ { some_equation ';'^ } } end^ when
    ;

//âœ… when-statement :
//âœ…    when expression then
//âœ…      { statement ";" }
//âœ…    { elsewhen expression then
//âœ…      { statement ";" }
//âœ…    }
//âœ…    end when
when_statement
    : when^ expression then^ { statement ';'^ } { elsewhen^ expression then^ { statement ';'^ } }
      end^ when
    ;

//âœ… connect-equation :
//âœ…    connect "(" component-reference "," component-reference ")"
connect_equation
    : connect '('^ component_reference ','^ component_reference ')'^
    ;

//=============================================================================
// A.2.7 Expressions
// âœ…: Implemented,  ğŸŸ¥: Not-Implemented, ğŸŸ¨: Partial
//âœ… expression :
//âœ…    simple-expression
//âœ…    | if expression then expression
//âœ…      { elseif expression then expression }
//âœ…      else expression
expression
    : simple_expression /*
     | if^ expression then^ expression { elseif^ expression then^ expression } else^ expression
     */
    ;

//âœ… simple-expression :
//âœ…    logical-expression [ ":" logical-expression [ ":" logical-expression ] ]
simple_expression
    : logical_expression [ ':'^ logical_expression [ ':'^ logical_expression ] ]
    ;

//âœ… logical-expression :
//âœ…    logical-term { or logical-term }
logical_expression
    : logical_term { or^ logical_term }
    ;

//âœ… logical-term :
//âœ…    logical-factor { and logical-factor }
logical_term
    : logical_factor { and^ logical_factor }
    ;

//âœ… logical-factor :
//âœ…    [ not ] relation
logical_factor
    : [ not ] relation
    ;

//âœ… relation :
//âœ…    arithmetic-expression [ relational-operator arithmetic-expression ]
relation
    : arithmetic_expression [ relational_operator arithmetic_expression ]
    ;

//âœ… relational-operator :
//âœ…    "<" | "<=" | ">" | ">=" | "==" | "<>"
relational_operator
    : '<'
    | '<='
    | '>'
    | '>='
    | '=='
    | '<>'
    ;

//âœ… arithmetic-expression :
//âœ…    [ add-operator ] term { add-operator term }
arithmetic_expression
    : [ add_operator ] term { add_operator term }
    ;

//âœ… add-operator :
//âœ…    "+" | "-" | ".+" | ".-"
add_operator
    : '+'
    | '-'
    | '.+'
    | '.-'
    ;

//âœ… term :
//âœ…    factor { mul-operator factor }
term: factor { mul_operator factor }
    ;

//âœ… mul-operator :
//âœ…    "*" | "/" | ".*" | "./"
mul_operator
    : '*'
    | '/'
    | '.*'
    | './'
    ;

//âœ… factor :
//âœ…    primary [ ( "^" | ".^" ) primary ]
factor
    : primary { ( '^' | '.^' ) primary }
    ;

//âœ… primary :
//âœ…    UNSIGNED-NUMBER
//âœ…    | STRING
//âœ…    | false
//âœ…    | true
//âœ…    | ( component-reference | der | initial | pure ) function-call-args
//âœ…    | component-reference
//âœ…    | "(" output-expression-list ")" [ ( array-subscripts | "." IDENT ) ]
//âœ…    | "[" expression-list { ";" expression-list } "]"
//âœ…    | "{" array-arguments "}"
//âœ…    | end
primary
    : unsigned_number
    | string
    | false
    | true // | ( component_reference | der | initial | pure ) function_call_args
    | component_reference // | '('^ output_expression_list ')' [ ( array_subscripts | '.'^ ident ) ]
// | '['^ expression_list { ';' expression_list } ']'^
// | '{'^ array_arguments '}'^
    | end
    ;

//âœ… UNSIGNED-NUMBER :
//âœ…    UNSIGNED-INTEGER | UNSIGNED-REAL
unsigned_number
    : unsigned_integer
    | unsigned_real
    ;

//âœ… type-specifier :
//âœ…    ["."] name
type_specifier
    : [ '.'^ ] name
    ;

//âœ… name :
//âœ…    IDENT { "." IDENT }
name: ident { '.'^ ident }
    ;

//âœ… component-reference :
//âœ…    [ "." ] IDENT [ array-subscripts ] { "." IDENT [ array-subscripts ] }
component_reference
    : [ '.'^ ] ident { '.'^ //[ array_subscripts ]
      ident [ array_subscripts ] }
    ;

//âœ… result-reference :
//âœ…    component-reference
//âœ…    | der "(" component-reference [ "," UNSIGNED-INTEGER ] ")"
// result_reference :
//     component_reference
//     | der '('^ component_reference [ ','^ unsigned_integer ] ')'^
//     ;
//âœ… function-call-args :
//âœ…    "(" [ function-arguments ] ")"
// function_call_args
//     : '('^ [ function_arguments ] ')'^
//     ;
//âœ… function-arguments :
//âœ…    expression [ "," function-arguments-non-first | for for-indices ]
//âœ…    | function-partial-application [ "," function-arguments-non-first ]
//âœ…    | named-arguments
// function_arguments
//     : expression [ ','^ function_arguments_non_first | for for_indices ]
//     | function_partial_application [ ','^ function_arguments_non_first ]
//     | named_arguments
//     ;
//âœ… function-arguments-non-first :
//âœ…    function-argument [ "," function-arguments-non-first ]
//âœ…    | named-arguments
// function_arguments_non_first
//     : function_argument [ ','^ function_arguments_non_first ]
//     | named_arguments
//     ;
//âœ… array-arguments :
//âœ…    expression [ "," array-arguments-non-first | for for-indices ]
// array_arguments
//     : expression [ ','^ array_arguments_non_first | for for_indices ]
//     ;
//âœ… array-arguments-non-first :
//âœ…    expression [ "," array-arguments-non-first ]
// array_arguments_non_first
//     : expression [ ','^ array_arguments_non_first ]
//     ;
//âœ… named-arguments: named-argument [ "," named-arguments ]
// named_arguments
//     : named_argument [ ','^ named_arguments ]
//     ;
//âœ… named-argument: IDENT "=" function-argument
// named_argument
//     : ident '='^ function_argument
//     ;
//âœ… function-argument :
//âœ…    function-partial-application | expression
// function_argument
//     : function_partial_application
//     | expression
//     ;
//âœ… function-partial-application :
//âœ…    function type-specifier "(" [ named-arguments ] ")"
// function_partial_application
//     : function type_specifier '('^ [ named_arguments ] ')'^
//     ;
//âœ… output-expression-list :
//âœ…    [ expression ] { "," [ expression ] }
// output_expression_list :
//     [ expression ] { ','^ [ expression ] }
//     ;
//âœ… expression-list :
//âœ…    expression { "," expression }
expression_list
    : expression { ','^ expression }
    ;

//âœ… array-subscripts :
//âœ…    "[" subscript { "," subscript } "]"
array_subscripts
    : '['^ subscript { ','^ subscript } ']'^
    ;

//âœ… subscript :
//âœ…    ":" | expression
subscript
    : ':'
    | expression
    ;

//âœ… description :
//âœ…    description-string [ annotation-clause ]
description
    : description_string [ annotation_clause ]
    ;

//âœ… description-string :
//âœ…    [ STRING { "+" STRING } ]
description_string
    : [ string { '+'^ string } ]
    ;

//âœ… annotation-clause :
//âœ…    annotation class-modification
annotation_clause
    : annotation class_modification
    ;
