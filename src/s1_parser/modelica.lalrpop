// Based on Modelica 3.7-dev Specification
use crate::s0_lexer::tokens::{Token, LexicalError};
use crate::s1_parser::ast;

grammar;

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// LALRPOP macros

CommaSeparatedList<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

PeriodSeparatedList<T>: Vec<T> = {
    <mut v:(<T> ".")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

SemicolonTerminatedList<T>: Vec<T> = {
    <v:(<T> ";")*> => v
};

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// 2.3.3 Modelica Keywords

extern {
    type Location = usize;
    type Error = LexicalError;
    enum Token {
        // keywords
        "algorithm" => Token::KeywordAlgorithm,
        "and" => Token::KeywordAnd,
        "annotation" => Token::KeywordAnnotation,
        "block" => Token::KeywordBlock,
        "break" => Token::KeywordBreak,
        "class" => Token::KeywordClass,
        "connect" => Token::KeywordConnect,
        "connector" => Token::KeywordConnector,
        "constant" => Token::KeywordConstant,
        "constrainedby" => Token::KeywordConstrainedby,
        "der" => Token::KeywordDer,
        "discrete" => Token::KeywordDiscrete,
        "each" => Token::KeywordEach,
        "else" => Token::KeywordElse,
        "elseif" => Token::KeywordElseif,
        "elsewhen" => Token::KeywordElsewhen,
        "encapsulated" => Token::KeywordEncapsulated,
        "end" => Token::KeywordEnd,
        "enumeration" => Token::KeywordEnumeration,
        "equation" => Token::KeywordEquation,
        "expandable" => Token::KeywordExpandable,
        "extends" => Token::KeywordExtends,
        "external" => Token::KeywordExternal,
        "final" => Token::KeywordFinal,
        "flow" => Token::KeywordFlow,
        "for" => Token::KeywordFor,
        "function" => Token::KeywordFunction,
        "if" => Token::KeywordIf,
        "import" => Token::KeywordImport,
        "impure" => Token::KeywordImpure,
        "in" => Token::KeywordIn,
        "initial" => Token::KeywordInitial,
        "inner" => Token::KeywordInner,
        "input" => Token::KeywordInput,
        "loop" => Token::KeywordLoop,
        "model" => Token::KeywordModel,
        "not" => Token::KeywordNot,
        "operator" => Token::KeywordOperator,
        "or" => Token::KeywordOr,
        "outer" => Token::KeywordOuter,
        "output" => Token::KeywordOutput,
        "package" => Token::KeywordPackage,
        "parameter" => Token::KeywordParameter,
        "partial" => Token::KeywordPartial,
        "protected" => Token::KeywordProtected,
        "public" => Token::KeywordPublic,
        "pure" => Token::KeywordPure,
        "record" => Token::KeywordRecord,
        "redeclare" => Token::KeywordRedeclare,
        "replaceable" => Token::KeywordReplaceable,
        "return" => Token::KeywordReturn,
        "stream" => Token::KeywordStream,
        "then" => Token::KeywordThen,
        "type" => Token::KeywordType,
        "when" => Token::KeywordWhen,
        "while" => Token::KeywordWhile,
        "within" => Token::KeywordWithin,

        // other lexical tokens
        "IDENT" => Token::Identifier(<String>),
        "STRING" => Token::String(<String>),
        "UNSIGNED-INTEGER" => Token::UnsignedInteger(<i64>),
        "UNSIGNED-REAL" => Token::UnsignedReal(<f64>),
        "boolean" => Token::Boolean(<bool>),
        "(" => Token::LParen,
        ")" => Token::RParen,
        "[" => Token::LBracket,
        "]" => Token::RBracket,
        "{" => Token::LBrace,
        "}" => Token::RBrace,
        ":=" => Token::Assign,
        "=" => Token::Equal,
        ";" => Token::Semicolon,
        "." => Token::Period,
        ":" => Token::Colon,
        "," => Token::Comma,
        "+" => Token::OperatorAdd,
        "-" => Token::OperatorSub,
        "*" => Token::OperatorMul,
        "/" => Token::OperatorDiv,
        "^" => Token::OperatorExp,

        ".+" => Token::OperatorElemAdd,
        ".-" => Token::OperatorElemSub,
        ".*" => Token::OperatorElemMul,
        "./" => Token::OperatorElemDiv,
        ".^" => Token::OperatorElemExp,

        "<" => Token::OperatorLessThan,
        "<=" => Token::OperatorLessThanOrEqual,
        ">" => Token::OperatorGreaterThan,
        ">=" => Token::OperatorGreaterThanOrEqual,
        "==" => Token::OperatorEqual,
        "<>" => Token::OperatorNotEqual,
    }
}

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// A.2.1 Stored Definition â€“ Within
// âœ…: Implemented,  ğŸŸ¥: Not-Implemented, ğŸŸ¨: Partial

//âœ… stored-definition :
//âœ…    [ within [ name ] ";" ]
//âœ…    { [ final ] class-definition ";" }
pub Within: ast::Name = {
    "within" <name:Name> ";" => name
}
pub StoredDefinition: ast::StoredDefinition = {
    <within: Within?>
    <classes:SemicolonTerminatedList<ClassDefinitionWithFinal>> => {
        ast::StoredDefinition {
            classes,
            within,
            rumoca_git_hash: "".to_string(),
            model_md5: "".to_string(),
        }
    }
}

pub ClassDefinitionWithFinal: ast::ClassDefinition = {
    <is_final: "final"?> <mut class: ClassDefinition> => {
        class.is_final = is_final.is_some();
        class
    }
}

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// A.2.2 Class Definition
// âœ…: Implemented,  ğŸŸ¥: Not-Implemented, ğŸŸ¨: Partial

//âœ… class-definition :
//âœ…    [ encapsulated ] class-prefixes class-specifier
pub ClassDefinition: ast::ClassDefinition = {
    <is_encapsulated: "encapsulated"?>
    <class_prefixes: ClassPrefixes>
    <class_specifier: ClassSpecifier> => {
        ast::ClassDefinition {
            is_final: false,
            is_encapsulated: is_encapsulated.is_some(),
            class_prefixes,
            class_specifier,
        }
    }
}
//âœ… class-prefixes :
//âœ…    [ partial ]
//âœ…    ( class
//âœ…      | model
//âœ…      | [ operator ] record
//âœ…      | block
//âœ…      | [ expandable ] connector
//âœ…      | type
//âœ…      | package
//âœ…      | [ pure | impure ] [ operator ] function
//âœ…      | operator
//âœ…    )
pub ClassPrefixes: ast::ClassPrefixes = {
    <partial: "partial"?> <class_type: ClassType> => {
        ast::ClassPrefixes {
            is_partial: partial.is_some(),
            class_type,
        }
    }
}

pub ClassType: ast::ClassType = {
    "model" => ast::ClassType::Model,
    "record" => ast::ClassType::Record,
    "operator" "record" => ast::ClassType::OperatorRecord,
    "block" => ast::ClassType::Block,
    "expandable" "connector" => ast::ClassType::ExpandableConnector,
    "connector" => ast::ClassType::Connector,
    "type" => ast::ClassType::Type,
    "package" => ast::ClassType::Package,
    "pure" "function" => ast::ClassType::PureFunction,
    "impure" "function" => ast::ClassType::ImpureFunction,
    "operator" "function" => ast::ClassType::OperatorFunction,
    "function" => ast::ClassType::Function,
    "operator" => ast::ClassType::Operator,
}

//âœ… class-specifier :
//âœ…    long-class-specifier
//ğŸŸ¥     | short-class-specifier
//ğŸŸ¥     | der-class-specifier
pub ClassSpecifier: ast::ClassSpecifier = {
    <spec: LongClassSpecifier> => spec,
}

//âœ… long-class-specifier :
//âœ…    IDENT description-string composition end IDENT
//ğŸŸ¥    | extends IDENT [ class-modification ] description-string composition end IDENT
pub LongClassSpecifier: ast::ClassSpecifier = {
    <name: "IDENT">
    <description: DescriptionString?>
    <composition: Composition>
    "end"
    <name_end: "IDENT"> => {
        ast::ClassSpecifier {
            name,
            description: description.unwrap_or(Vec::new()),
            composition,
            name_end,
        }
    }
}

//ğŸŸ¥ short-class-specifier :
//ğŸŸ¥    IDENT "=" base-prefix type-specifier [ array-subscripts ] [ class-modification ] description
//ğŸŸ¥    | IDENT "=" enumeration "(" ( [ enum-list ] | ":" ) ")" description

//ğŸŸ¥ der-class-specifier :
//ğŸŸ¥    IDENT "=" der "(" type-specifier "," IDENT { "," IDENT } ")" description

//ğŸŸ¥ base-prefix :
//ğŸŸ¥    [ input | output ]

//ğŸŸ¥ enum-list :
//ğŸŸ¥    enumeration-literal { "," enumeration-literal }

//ğŸŸ¥ enumeration-literal :
//ğŸŸ¥    IDENT description

//âœ… composition :
//âœ…    element-list
//âœ…    { public element-list
//âœ…      | protected element-list
//âœ…      | equation-section
//âœ…      | algorithm-section
//âœ…    }
//ğŸŸ¥    [ external [ language-specification ]
//ğŸŸ¥      [ external-function-call ] [ annotation-clause ] ";"
//ğŸŸ¥    ]
//ğŸŸ¥    [ annotation-clause ";" ]
pub Composition: Vec<ast::CompositionPart> = {
    <first:ElementList>
    <remaining: CompositionPart*>
    => {
        let mut v = Vec::new();
        v.push(ast::CompositionPart::ElementList {
            visibility: ast::Visibility::Public,
            elements: first,
        });
        v.extend(remaining);
        v
    }
}

pub CompositionPart: ast::CompositionPart = {
    <comp: ElementListWithVisibility> => comp,
    <comp: EquationSection> => comp,
    <comp: AlgorithmSection> => comp,
}

pub ElementListWithVisibility: ast::CompositionPart = {
    <visibility:Visibility> <elements: ElementList> => {
        ast::CompositionPart::ElementList {
            visibility,
            elements,
        }
    }
}

pub Visibility: ast::Visibility = {
    "public" => ast::Visibility::Public,
    "protected" => ast::Visibility::Protected,
}

//âœ… language-specification :
//âœ…    STRING
pub LanguageSpecification: String = {
    <string:"STRING"> => string 
}
//ğŸŸ¥ external-function-call :
//ğŸŸ¥    [ component-reference "=" ] IDENT "(" [ expression-list ] ")"

//âœ… element-list :
//âœ…    { element ";" }
pub ElementList: Vec<ast::Element> = {
    <elements:SemicolonTerminatedList<Element>> => elements
}

//ğŸŸ¨ element :
//ğŸŸ¥    import-clause
//ğŸŸ¥    | extends-clause
//ğŸŸ¨    | [ redeclare ] [ final ] [ inner ] [ outer ] (
//ğŸŸ¥        class-definition
//ğŸŸ¥        | component-clause
//ğŸŸ¥        | replaceable (
//ğŸŸ¥          class-definition
//âœ…          | component-clause)
//ğŸŸ¥        [ constraining-clause description ])
pub Element : ast::Element = {
    <elem: ComponentClause> => elem
}

//ğŸŸ¥ import-clause :
//ğŸŸ¥    import
//ğŸŸ¥    ( IDENT "=" name
//ğŸŸ¥      | name [ ".*" | "." ( "*" | "{" import-list "}" ) ]
//ğŸŸ¥    )
//ğŸŸ¥    description

//ğŸŸ¥ import-list :
//ğŸŸ¥    IDENT { "," IDENT }


// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// A.2.3 Extends
// âœ…: Implemented,  ğŸŸ¥: Not-Implemented, ğŸŸ¨: Partial

//ğŸŸ¥ extends-clause :
//ğŸŸ¥    extends type-specifier [ class-or-inheritance-modification ] [ annotation-clause ]

//ğŸŸ¥ constraining-clause :
//ğŸŸ¥    constrainedby type-specifier [ class-modification ]

//ğŸŸ¥ class-or-inheritance-modification :
//ğŸŸ¥    "(" [ argument-or-inheritance-modification-list ] ")"

//ğŸŸ¥ argument-or-inheritance-modification-list :
//ğŸŸ¥     ( argument | inheritance-modification ) { "," ( argument | inheritance-modification ) }

//ğŸŸ¥ inheritance-modification :
//ğŸŸ¥     break ( connect-equation | IDENT )

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// A.2.4 Component Clause
// âœ…: Implemented,  ğŸŸ¥: Not-Implemented, ğŸŸ¨: Partial

//âœ… component-clause :
//âœ…    type-prefix type-specifier [ array-subscripts ] component-list
pub ComponentClause: ast::Element = {
    <type_prefix: TypePrefix>
    <type_specifier: TypeSpecifier>
    <array_subscripts: ArraySubscripts?>
    <components: ComponentList> => {
        ast::Element::ComponentClause {
            type_prefix,
            type_specifier,
            array_subscripts,
            components,
        }
    }
}

//âœ… type-prefix :
//âœ…    [ flow | stream ]
//âœ…    [ discrete | parameter | constant ]
//âœ…    [ input | output ]
pub TypePrefix: ast::TypePrefix = {
    <connection: Connection?>
    <variability: Variability?>
    <causality: Causality?> => {
        ast::TypePrefix {
            connection: connection.unwrap_or(ast::Connection::None),
            variability: variability.unwrap_or(ast::Variability::Continuous),
            causality: causality.unwrap_or(ast::Causality::None),
        }
    }
}
pub Connection: ast::Connection = {
    "flow" => ast::Connection::Flow,
    "stream" => ast::Connection::Stream,
}
pub Variability: ast::Variability = {
    "discrete" => ast::Variability::Discrete,
    "parameter" => ast::Variability::Parameter,
    "constant" => ast::Variability::Constant,
}
pub Causality: ast::Causality = {
    "input" => ast::Causality::Input,
    "output" => ast::Causality::Output,
}
//âœ… component-list :
//âœ…    component-declaration { "," component-declaration }
pub ComponentList: Vec<ast::ComponentDeclaration> = {
    <components: CommaSeparatedList<ComponentDeclaration>> => {
        components
    }
}
//âœ… component-declaration :
//âœ…    declaration [ condition-attribute ] description
pub ComponentDeclaration: ast::ComponentDeclaration = {
    <declaration: Declaration>
    <condition_attribute: ConditionAttribute?>
    <description: Description>
    => {
        ast::ComponentDeclaration{
            declaration,
            condition_attribute,
            description,
        }
    }
}
//âœ… condition-attribute :
//âœ…    if expression
pub ConditionAttribute: Box<ast::Expression> = {
    "if" <cond: Expression> => cond
}
//âœ… declaration :
//âœ…    IDENT [ array-subscripts ] [ modification ]
pub Declaration: ast::Declaration = {
    <name: "IDENT">
    <array_subscripts:ArraySubscripts?>
    <modification:Modification?> => {
        ast::Declaration {
            name,
            array_subscripts,
            modification,
        }
    }
}

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// A.2.5 Modification
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// âœ…: Implemented,  ğŸŸ¥: Not-Implemented, ğŸŸ¨: Partial

//ğŸŸ¨ modification :
//ğŸŸ¥    class-modification [ "=" modification-expression ]
//ğŸŸ¨    | "=" modification-expression
pub Modification: ast::Modification = {
    "=" <expression: Expression> => ast::Modification {
        expression
    }
}

//ğŸŸ¥ modification-expression :
//ğŸŸ¥    expression
//ğŸŸ¥    | break

//âœ… class-modification :
//âœ…    "(" [ argument-list ] ")"
pub ClassModification: Vec<ast::Argument> = {
    "(" <args: CommaSeparatedList<Argument>> ")" => args
}

//âœ… argument-list :
//âœ…    argument { "," argument }
// NOTE: flattend into class-modification above

//ğŸŸ¨ argument :
//ğŸŸ¨    element-modification-or-replaceable
//ğŸŸ¥    | element-redeclaration
pub Argument: ast::Argument = {
    <each: "each"?> <is_final: "final"?> <name: Name> <modification: Modification?> <description: Description> => {
        ast::Argument::Modification {
            name,
            modification,
            description,
            each: each.is_some(),
            is_final: is_final.is_some(),
        }
    },
}

//ğŸŸ¥ element-modification-or-replaceable :
//ğŸŸ¥    [ each ] [ final ] ( element-modification | element-replaceable )

//ğŸŸ¨ element-modification :
//ğŸŸ¨    name [ modification ] description-string

//ğŸŸ¥ element-redeclaration :
//ğŸŸ¥    redeclare [ each ] [ final ]
//ğŸŸ¥    ( short-class-definition | component-clause1 | element-replaceable )

//ğŸŸ¥ element-replaceable :
//ğŸŸ¥    replaceable ( short-class-definition | component-clause1 )
//ğŸŸ¥    [ constraining-clause ]

//âœ… component-clause1 :
//âœ…    type-prefix type-specifier component-declaration1
pub ComponentClause1: ast::ComponentClause1 = {
    <type_prefix: TypePrefix>
    <type_specifier: TypeSpecifier>
    <component_declaration1: ComponentDeclaration1> => {
        ast::ComponentClause1 {
            type_prefix,
            type_specifier,
            component_declaration1,
        }
    }
}

//âœ… component-declaration1 :
//âœ…    declaration description
pub ComponentDeclaration1: ast::ComponentDeclaration1 = {
    <declaration: Declaration>
    <description: Description> => {
        ast::ComponentDeclaration1 {
            declaration,
            description,
        }
    }
}

//ğŸŸ¥ short-class-definition :
//ğŸŸ¥    class-prefixes short-class-specifier

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// A.2.6 Equations
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// âœ…: Implemented,  ğŸŸ¥: Not-Implemented, ğŸŸ¨: Partial

//âœ… equation-section :
//âœ…    [ initial ] equation { some-equation ";" }
pub EquationSection: ast::CompositionPart = {
    <initial:"initial"?> "equation" <equations:SemicolonTerminatedList<Equation>> => {
        ast::CompositionPart::EquationSection {
            initial: initial.is_some(),
            equations,
        }
    }
}
//âœ… algorithm-section :
//âœ…    [ initial ] algorithm { statement ";" }
pub AlgorithmSection: ast::CompositionPart = {
    <initial:"initial"?> "algorithm" <statements:SemicolonTerminatedList<Statement>> => {
        ast::CompositionPart::AlgorithmSection {
            initial: initial.is_some(),
            statements,
        }
    }
}

//ğŸŸ¥ some-equation :
//âœ…    ( simple-expression "=" expression
//âœ…      | if-equation
//ğŸŸ¥      | for-equation
//ğŸŸ¥      | connect-equation
//ğŸŸ¥      | when-equation
//ğŸŸ¥      | component-reference function-call-args )
//ğŸŸ¥    description
pub Equation: ast::Equation = {
    <lhs:SimpleExpression> "=" <rhs:Expression> => {
        ast::Equation::Simple {
            lhs,
            rhs
        }
    },
    "der" "(" <comp:ComponentReference> ")" "=" <rhs:Expression> => {
        ast::Equation::Der {
            comp,
            rhs
        }
    },
    <eq: IfEquation> => eq,
}

//âœ… statement :
//âœ…    ( component-reference ( ":=" expression | function-call-args )
//ğŸŸ¥      | "(" output-expression-list ")" ":=" component-reference function-call-args
//ğŸŸ¥      | break
//ğŸŸ¥      | return
//ğŸŸ¥      | if-statement
//ğŸŸ¥      | for-statement
//ğŸŸ¥      | while-statement
//ğŸŸ¥      | when-statement )
//ğŸŸ¥    description

pub Statement: ast::Statement = {
    <comp: ComponentReference> ":=" <rhs:Expression> => {
        ast::Statement::Assignment{
            comp,
            rhs
        }
    },
    <stmt: IfStatement> => stmt,
}

//âœ… if-equation :
//âœ…    if expression then
//âœ…      { some-equation ";" }
//âœ…    { elseif expression then
//âœ…      { some-equation ";" }
//âœ…    }
//âœ…    [ else
//âœ…      { some-equation ";" }
//âœ…    ]
//âœ…    end if

pub IfEquation: ast::Equation = {
    "if" <if_cond:Expression> "then"
    <if_eqs:SemicolonTerminatedList<Equation>>
    <else_if_blocks: ElseIfEquationBlock*>
    <else_eqs: ElseEquationBlock?>
    "end" "if" => {
        ast::Equation::If {
            if_cond,
            if_eqs,
            else_if_blocks,
            else_eqs: else_eqs.unwrap_or(Vec::new()),
        }
    }
}

pub ElseIfEquationBlock: ast::ElseIfEquationBlock = {
    "elseif" <cond:Expression> "then"
    <eqs:SemicolonTerminatedList<Equation>> => {
        ast::ElseIfEquationBlock {
            cond, eqs
        }
    }
}

pub ElseEquationBlock: Vec<ast::Equation> = {
    "else" <eqs:SemicolonTerminatedList<Equation>> => {
        eqs
    }
}

//âœ… if-statement :
//âœ…    if expression then
//âœ…      { statement ";" }
//âœ…    { elseif expression then
//âœ…      { statement ";" }
//âœ…    }
//âœ…    [ else
//âœ…      { statement ";" }
//âœ…    ]
//âœ…    end if
pub IfStatement: ast::Statement = {
    "if" <if_cond:Expression> "then"
    <if_eqs:SemicolonTerminatedList<Statement>>
    <else_if_blocks: ElseIfStatementBlock*>
    <else_eqs: ElseStatementBlock?>
    "end" "if" => {
        ast::Statement::If {
            if_cond, if_eqs,
            else_if_blocks,
            else_eqs: else_eqs.unwrap_or(Vec::new()),
        }
    }
}

pub ElseIfStatementBlock: ast::ElseIfStatementBlock = {
    "elseif" <cond:Expression> "then"
    <eqs:SemicolonTerminatedList<Statement>> => {
        ast::ElseIfStatementBlock {
            cond, eqs
        }
    }
}

pub ElseStatementBlock: Vec<ast::Statement> = {
    "else" <eqs:SemicolonTerminatedList<Statement>> => {
        eqs
    }
}

//ğŸŸ¥ for-equation :
//ğŸŸ¥    for for-indices loop
//ğŸŸ¥      { some-equation ";" }
//ğŸŸ¥    end for
//ğŸŸ¥ for-statement :
//ğŸŸ¥    for for-indices loop
//ğŸŸ¥      { statement ";" }
//ğŸŸ¥    end for
//ğŸŸ¥ for-indices :
//ğŸŸ¥    for-index { "," for-index }
//ğŸŸ¥ for-index :
//ğŸŸ¥    IDENT [ in expression ]
//ğŸŸ¥ while-statement :
//ğŸŸ¥    while expression loop
//ğŸŸ¥      { statement ";" }
//ğŸŸ¥    end while
//ğŸŸ¥ when-equation :
//ğŸŸ¥    when expression then
//ğŸŸ¥      { some-equation ";" }
//ğŸŸ¥    { elsewhen expression then
//ğŸŸ¥      { some-equation ";" }
//ğŸŸ¥    }
//ğŸŸ¥    end when
//ğŸŸ¥ when-statement :
//ğŸŸ¥    when expression then
//ğŸŸ¥      { statement ";" }
//ğŸŸ¥    { elsewhen expression then
//ğŸŸ¥      { statement ";" }
//ğŸŸ¥    }
//ğŸŸ¥    end when
//ğŸŸ¥ connect-equation :
//ğŸŸ¥    connect "(" component-reference "," component-reference ")"

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// A.2.7 Expressions
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// âœ…: Implemented,  ğŸŸ¥: Not-Implemented, ğŸŸ¨: Partial


//ğŸŸ¨ expression :
//âœ…     simple-expression
//ğŸŸ¥    | if expression then expression
//ğŸŸ¥      { elseif expression then expression }
//ğŸŸ¥      else expression
//âœ…  simple-expression :
//âœ…     logical-expression [ ":" logical-expression [ ":" logical-expression ] ]

pub Expression: Box<ast::Expression> = {
    <simp:SimpleExpression> => {
        simp
    },
    // "if" <if_cond:SimpleExpression> "then" <if_eq:SimpleExpression>
    // <else_if_blocks: ElseIfExpressionBlock*>
    // <else_eq: ElseExpressionBlock?>
    //  => {
    //     Box::new(ast::Expression::If {
    //         if_cond, if_eq,
    //         else_if_blocks,
    //         else_eq,
    //     })
    // },
}

pub ElseIfExpressionBlock: ast::ElseIfExpressionBlock = {
    "elseif" <cond:SimpleExpression> "then" <then:SimpleExpression>  => {
        ast::ElseIfExpressionBlock {
            cond, then
        }
    }
}

pub ElseExpressionBlock: Box<ast::Expression> = {
    "else" <eq:SimpleExpression> => {
        eq
    }
}

pub ParenthesisExpression = SimpleExpression;

pub SimpleExpression: Box<ast::Expression> = {
//âœ… simple-expression :
//âœ…    logical-expression [ ":" logical-expression [ ":" logical-expression ] ]
    #[precedence(level="11")] #[assoc(side="left")]
    <lhs:SimpleExpression> ":" <rhs:SimpleExpression> => {
        Box::new(ast::Expression::Range {
            lhs,
            rhs,
        })
    },
//âœ… logical-expression :
//âœ…    logical-term { or logical-term }
    #[precedence(level="10")] #[assoc(side="left")]
    <lhs:SimpleExpression> "or" <rhs:SimpleExpression> => {
        Box::new(ast::Expression::Or {
            lhs,
            rhs
        })
    },
//âœ… logical-term :
//âœ…    logical-factor { and logical-factor }
    #[precedence(level="9")] #[assoc(side="left")]
    <lhs:SimpleExpression> "and" <rhs:SimpleExpression> => {
        Box::new(ast::Expression::And {
            lhs,
            rhs
        })
    },
//âœ… logical-factor :
//âœ…    [ not ] relation
    #[precedence(level="8")]
    "not" <rhs:SimpleExpression> => {
        Box::new(ast::Expression::Not {
            rhs
        })
    },
//âœ… relation :
//âœ…    arithmetic-expression [ relational-operator arithmetic-expression ]
//âœ… relational-operator :
//âœ…    "<" | "<=" | ">" | ">=" | "==" | "<>"
    #[precedence(level="7")] #[assoc(side="left")]
    <lhs:SimpleExpression> "<" <rhs:SimpleExpression> => {
        Box::new(ast::Expression::LessThan {
            lhs,
            rhs
        })
    },
    <lhs:SimpleExpression> ">" <rhs:SimpleExpression> => {
        Box::new(ast::Expression::GreaterThan {
            lhs,
            rhs
        })
    },
    <lhs:SimpleExpression> "<=" <rhs:SimpleExpression> => {
        Box::new(ast::Expression::LessThanOrEqual {
            lhs,
            rhs
        })
    },
    <lhs:SimpleExpression> ">=" <rhs:SimpleExpression> => {
        Box::new(ast::Expression::GreaterThanOrEqual {
            lhs,
            rhs
        })
    },
    <lhs:SimpleExpression> "==" <rhs:SimpleExpression> => {
        Box::new(ast::Expression::Equal {
            lhs,
            rhs
        })
    },
    <lhs:SimpleExpression> "<>" <rhs:SimpleExpression> => {
        Box::new(ast::Expression::NotEqual {
            lhs,
            rhs
        })
    },
    #[precedence(level="12")] #[assoc(side="left")]
    "-" <rhs:SimpleExpression> => {
        Box::new(ast::Expression::Negative {
            rhs
        })
    },
//âœ… arithmetic-expression :
//âœ…    [ add-operator ] term { add-operator term }
//âœ… add-operator :
//âœ…    "+" | "-" | ".+" | ".-"
    #[precedence(level="5")] #[assoc(side="left")]
    <lhs:SimpleExpression> "+" <rhs:SimpleExpression> => {
        Box::new(ast::Expression::Add {
            lhs,
            rhs
        })
    },
    <lhs:SimpleExpression> ".+" <rhs:SimpleExpression> => {
        Box::new(ast::Expression::ElemAdd {
            lhs,
            rhs
        })
    },
    <lhs:SimpleExpression> "-" <rhs:SimpleExpression> => {
        Box::new(ast::Expression::Sub {
            lhs,
            rhs
        })
    },
    <lhs:SimpleExpression> ".-" <rhs:SimpleExpression> => {
        Box::new(ast::Expression::ElemSub {
            lhs,
            rhs
        })
    },
//âœ… term :
//âœ…    factor { mul-operator factor }
//âœ… mul-operator :
//âœ…    "*" | "/" | ".*" | "./"
    #[precedence(level="4")] #[assoc(side="left")]
    <lhs:SimpleExpression> "*" <rhs:SimpleExpression> => {
        Box::new(ast::Expression::Mul {
            lhs,
            rhs
        })
    },
    <lhs:SimpleExpression> ".*" <rhs:SimpleExpression> => {
        Box::new(ast::Expression::ElemMul {
            lhs,
            rhs
        })
    },
    <lhs:SimpleExpression> "/" <rhs:SimpleExpression> => {
        Box::new(ast::Expression::Div {
            lhs,
            rhs
        })
    },
    <lhs:SimpleExpression> "./" <rhs:SimpleExpression> => {
        Box::new(ast::Expression::ElemDiv {
            lhs,
            rhs
        })
    },
//âœ… factor :
//âœ…    primary [ ( "^" | ".^" ) primary ]
    #[precedence(level="3")] #[assoc(side="left")]
    <lhs:SimpleExpression> "^" <rhs:SimpleExpression> => {
        Box::new(ast::Expression::Exp {
            lhs,
            rhs
        })
    },
    <lhs:SimpleExpression> ".^" <rhs:SimpleExpression> => {
        Box::new(ast::Expression::ElemExp {
            lhs,
            rhs
        })
    },
//âœ… primary :
//âœ…    UNSIGNED-NUMBER
//ğŸŸ¥    | STRING
//âœ…    | false
//âœ…    | true
//ğŸŸ¨    | ( component-reference | der | initial | pure ) function-call-args
//âœ…    | component-reference
//ğŸŸ¥    | "(" output-expression-list ")" [ ( array-subscripts | "." IDENT ) ]
//ğŸŸ¥    | "[" expression-list { ";" expression-list } "]"
//ğŸŸ¥    | "{" array-arguments "}"
//ğŸŸ¥    | end
    #[precedence(level="0")]
    "(" <rhs:ParenthesisExpression> ")" => {
        Box::new(ast::Expression::Parenthesis {
            rhs
        })
    },
    "{" <args:CommaSeparatedList<Expression>> "}" => {
        Box::new(ast::Expression::ArrayArguments {
            args
        })
    },
    <val:"UNSIGNED-INTEGER"> => {
        Box::new(ast::Expression::UnsignedInteger(val))
    },
    <val:"UNSIGNED-REAL"> => {
        Box::new(ast::Expression::UnsignedReal(val))
    },
    <val:"boolean"> => {
        Box::new(ast::Expression::Boolean(val))
    },
    <comp:ComponentReference> => {
        Box::new(ast::Expression::Ref{comp})
    },
    <comp:ComponentReference> <args:FunctionCallArguments> => {
        Box::new(ast::Expression::FunctionCall {
            comp,
            args
        })
    },
}

//âœ… UNSIGNED-NUMBER :
//âœ…    UNSIGNED-INTEGER | UNSIGNED-REAL
// NOTE: flattened in primary

//âœ… type-specifier :
//âœ…    ["."] name
pub TypeSpecifier: ast::TypeSpecifier = {
    <leading_period: "."?> <name: Name> => {
        ast::TypeSpecifier{
            leading_period: leading_period.is_some(),
            name,
        }
    },
}
//âœ… name :
//âœ…    IDENT { "." IDENT }
pub Name: ast::Name = {
    <first:"IDENT"> <remaining: ("." <"IDENT">)*> => {
        let mut v = vec![first];
        v.extend(remaining);
        ast::Name {
            ident: v
        }
    }
}


//âœ… component-reference :
//âœ…    [ "." ] IDENT [ array-subscripts ] { "." IDENT [ array-subscripts ] }
pub ComponentReference: ast::ComponentReference = {
    <local: "."?> <parts: RefPart+> => {
        ast::ComponentReference{
            local: local.is_some(),
            parts,
        }
    },
}
pub RefPart: ast::RefPart = {
    <name:"IDENT"> <array_subscripts:ArraySubscripts?> => {
        ast::RefPart {
            name,
            array_subscripts: array_subscripts.unwrap_or(Vec::new()),
        }
    }
}

//ğŸŸ¥ result-reference :
//ğŸŸ¥    component-reference
//ğŸŸ¥    | der "(" component-reference [ "," UNSIGNED-INTEGER ] ")"

//âœ… function-call-args :
//âœ…    "(" [ function-arguments ] ")"
pub FunctionCallArguments: Vec<Box<ast::Expression>> = {
    "(" <args:CommaSeparatedList<Expression>> ")"  => args,
}

//ğŸŸ¥ function-arguments :
//ğŸŸ¥    expression [ "," function-arguments-non-first | for for-indices ]
//ğŸŸ¥    | function-partial-application [ "," function-arguments-non-first ]
//ğŸŸ¥    | named-arguments

//ğŸŸ¥ function-arguments-non-first :
//ğŸŸ¥    function-argument [ "," function-arguments-non-first ]
//ğŸŸ¥    | named-arguments

//ğŸŸ¥ array-arguments :
//ğŸŸ¥    expression [ "," array-arguments-non-first | for for-indices ]

//ğŸŸ¥ array-arguments-non-first :
//ğŸŸ¥    expression [ "," array-arguments-non-first ]

//ğŸŸ¥ named-arguments: named-argument [ "," named-arguments ]

//ğŸŸ¥ named-argument: IDENT "=" function-argument

//ğŸŸ¥ function-argument :
//ğŸŸ¥    function-partial-application | expression

//ğŸŸ¥ function-partial-application :
//ğŸŸ¥    function type-specifier "(" [ named-arguments ] ")"

//ğŸŸ¥ output-expression-list :
//ğŸŸ¥    [ expression ] { "," [ expression ] }

//ğŸŸ¥ expression-list :
//ğŸŸ¥    expression { "," expression }

//âœ… array-subscripts :
//âœ…    "[" subscript { "," subscript } "]"
pub ArraySubscripts: Vec<ast::Subscript> = {
    "[" <subscripts: CommaSeparatedList<Subscript>> "]" => {
        subscripts
    },
}
//âœ… subscript :
//âœ…    ":" | expression
pub Subscript: ast::Subscript = {
    ":" => ast::Subscript::Colon,
    <expr: Expression> => ast::Subscript::Expression(expr),
}

//âœ… description :
//âœ…    description-string [ annotation-clause ]
pub Description: ast::Description = {
    <strings: DescriptionString?>
    <annotation: AnnotationClause?>
    => {
        ast::Description {
            strings: strings.unwrap_or(Vec::new()),
            annotation: annotation.unwrap_or(Vec::new()),
        }
    },
}

//âœ… description-string :
//âœ…    [ STRING { "+" STRING } ]
// Note: LALRPOP doesn't like empty expressions, so effectively
//       removing outer [ ], and at least one string is required.
//       Other expressions will need to treat as option.
pub DescriptionString: Vec<String> = {
    <first:"STRING"> <remaining: ("+" <"STRING">)*> => {
        let mut v = vec![first];
        v.extend(remaining);
        v
    }
}

//âœ… annotation-clause :
//âœ…    annotation class-modification
pub AnnotationClause: Vec<ast::Argument> = {
    "annotation" <modification:ClassModification> => {
        modification
    },
}